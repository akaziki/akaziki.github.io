{"meta":{"title":"Akaziki","subtitle":"Output is input","description":null,"author":"Akaziki","url":"http://akaziki.github.io"},"pages":[{"title":"","date":"2017-10-16T01:17:17.000Z","updated":"2017-11-02T14:07:26.000Z","comments":false,"path":"about/index.html","permalink":"http://akaziki.github.io/about/index.html","excerpt":"","text":"李令晓，就读于广东工业大学热爱星空与音乐，前端菜鸟一枚今夜月色很美友情链接Jinlong’s Blog"},{"title":"Tags","date":"2017-10-16T01:11:17.000Z","updated":"2017-10-16T05:12:22.000Z","comments":false,"path":"tags/index.html","permalink":"http://akaziki.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"简易的cocos_toast_component","slug":"简易的cocos-toast-component","date":"2018-11-28T03:21:03.000Z","updated":"2018-11-28T03:24:02.434Z","comments":true,"path":"2018/11/28/简易的cocos-toast-component/","link":"","permalink":"http://akaziki.github.io/2018/11/28/简易的cocos-toast-component/","excerpt":"","text":"cocos_toast_component 代码地址：https://github.com/akaziki/cocos_toast_component 一个简单的 tost 组件，用法： 12var Toast = reqire('Toast.js')Toast(text,&#123;[gravity],[duration],[bg_color]&#125;) text:要显示的字符串 gravity(可选):位置，String 类型，可选值(‘CENTER’,’TOP’,’BOTTOM’),默认为’CENTER’ duration(可选):时间，Number 类型，单位为秒，默认 1s bg_color(可选):颜色，cc.color 类型，默认 cc.color(102, 102, 102, 200)","categories":[],"tags":[{"name":"cocos","slug":"cocos","permalink":"http://akaziki.github.io/tags/cocos/"}]},{"title":"WSL环境配置","slug":"WSL环境配置","date":"2018-11-28T03:01:11.000Z","updated":"2018-11-28T03:01:52.701Z","comments":true,"path":"2018/11/28/WSL环境配置/","link":"","permalink":"http://akaziki.github.io/2018/11/28/WSL环境配置/","excerpt":"","text":"zsh和oh-my-zsh12sudo apt install zshsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 设置terminal的shell环境默认为zsh，输入以下命令1chsh -s /bin/zsh 这条命令的 ` 是键盘tab上面的那个 ,接下来重启终端 zsh颜色主题和终端颜色主题 (Color Theme)要配置两个部分：zsh主题（zsh theme）和终端的颜色主题（Color Theme） 由于使用了oh-my-zsh，修改zsh的主题很容易，只要编辑~/.zshrc文件，找到ZSH_THEME一行，改为agnoster即可 但是Windows默认终端的Color Theme改起来比较费劲，需要使用一个叫做colortool的工具。他是微软自带的一个修改终端配色方案的工具首先在这里 下载 下载colortool.zip并解压后，进入文件夹，按住shift并点击右键选择在此处打开Powershell窗口 在其中输入 1.\\colortool.exe -d solarized_dark 回车后，关闭这个新打开的Powershell窗口，回到之前的WSL窗口，输入如下命令以使zsh配置生效: 1source ~/.zshrc 安装 Fira Code字体点击这里下载：https://raw.githubusercontent.com/tonsky/FiraCode/master/distr/ttf/FiraCode-Retina.ttf 插件推荐zoh-my-zsh自带插件，开启即可 快捷访问常用目录的插件，可以让你非常方便的访问经常要使用的目录 比如我经常使用 cd ~/workspace/mpa-web，安装后可以z m[tab][return]来快速访问 PS: 刚装上后需要输入几次正常的 cd 命令之后他才能搜集到足够的信息整理出常用路径 doh-my-zsh自带插件，开启即可 使用命令d列出历史纪录中10个最近的目录，输入数字可以直接跳转在跳来跳去配置环境时很有用，因为你往往不记得刚才的配置文件在哪个路径里面 colored-man-pagesoh-my-zsh自带插件，开启即可给man命令中的文档加上一些语法高亮。man命令可以用来查看其他命令的文档，比如man git就会展示git命令的介绍。使用这个插件之后可以让这个文档可读性稍微好一点点 syntax-highlighting &amp; zsh-autosuggestions插件repo https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md 这两个插件可以让你在终端输入命令时有语法高亮和自动补全。虽然放在了最后，但是这两个插件才是zsh真正的killer plugin :p 使用同样很简单，先通过如下命令安装： 1cd ~/ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 然后和上面一样，在 .zshrc 加上插件名即可。 上面所有插件都打开的话，~/.zshrc中应该这样写: 1plugins=(z d colored-man-pages zsh-autosuggestions zsh-syntax-highlighting) 安装node首先安装必要的包。12sudo apt-get updatesudo apt-get install build-essential libssl-dev 然后安装nvm的脚本，有两种方法curl或wget通过curl: 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash 通过wget: 1wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash 检查安装及使用注意，此处需要重启terminal终端才能生效。使用nvm –help查看是否安装成功。使用nvm ls查看已经安装的版本。使用nvm ls-remote查看所有远端版本。使用nvm install安装某个版本，如nvm install v5.3.0。 使用nvm use切换到某个版本，如nvm use v5.3.0使用5.3.0，nvm use system使用系统版本。 设置镜像源为淘宝1npm config set registry https://registry.npm.taobao.org 配置别名1vim ~/.bashrc 在文件中添加，如下： 123alias AD7='cd ~/GS700E/android/kernel/arch/arm64/boot/dts'alias AD5='cd ~/AD500A/android/kernel/arch/arm/boot/dts'alias GS7='cd ~/AD700A/android/kernel/arch/arm64/boot/dts' 保存退出,然后执行： 1source ~/.bashrc zsh配置别名1vim ~/.zshrc 在文件中添加，如下： 123alias AD7='cd ~/GS700E/android/kernel/arch/arm64/boot/dts'alias AD5='cd ~/AD500A/android/kernel/arch/arm/boot/dts'alias GS7='cd ~/AD700A/android/kernel/arch/arm64/boot/dts' 保存退出,然后执行： 1source ~/.zshrc OpenSSH Server 设定首先，先使用 ssh-keygen 产生key，接着打开sshd_config 來编辑设定： 12sudo /usr/bin/ssh-keygen -Asudo vim /etc/ssh/sshd_config 启动OpenSSH Server ： 1sudo /etc/init.d/ssh start 配置 VSCode 终端默认使用 WSL 的 bash1234&#123; \"terminal.integrated.shell.windows\": \"C:\\\\Windows\\\\System32\\\\wsl.exe\", \"terminal.integrated.fontFamily\": \"Menlo for Powerline\"//字体&#125; 如果要调用 32 位进程，需要配置使用 Sysnative：C:\\\\Windows\\\\sysnative\\\\bash.exe 如果 VSCode 是 64 位版本，可以直接使用：C:\\\\WINDOWS\\\\System32\\\\bash.exe 或者 C:\\\\WINDOWS\\\\System32\\\\wsl.exe","categories":[],"tags":[{"name":"wsl","slug":"wsl","permalink":"http://akaziki.github.io/tags/wsl/"}]},{"title":"前端知识汇总","slug":"前端校招总结-内附最新面试知识点与解答","date":"2017-11-15T07:31:19.000Z","updated":"2018-11-28T03:20:10.026Z","comments":true,"path":"2017/11/15/前端校招总结-内附最新面试知识点与解答/","link":"","permalink":"http://akaziki.github.io/2017/11/15/前端校招总结-内附最新面试知识点与解答/","excerpt":"","text":"HTML(Hypertext Markup Language)&lt;!DOCTYPE&gt;的作用 指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令 HTML5新特性，语义化 文件类型声明（&lt;!DOCTYPE&gt;）仅有一型：&lt;!DOCTYPE HTML&gt;。 新的解析顺序：不再基于SGML。 新的元素：section, video, progress, nav, meter, time, aside, canvas, command, datalist, details, embed, figcaption, figure, footer, header, hgroup, keygen, mark, output, rp, rt, ruby, source, summary, wbr。 input元素的新类型：date, email, url等等。 新的属性：ping（用于a与area）, charset（用于meta）, async（用于script）。 全域属性：id, tabindex, repeat。 新的全域属性：contenteditable, contextmenu, draggable, dropzone, hidden, spellcheck。 浏览器的 和怪异模式 先说一下在什么情况下，用那种模式： 标准模式：在现有有doctype声明的网页，绝大多数是采用strict mode进行解析的。 怪异模式：浏览器对没有进行doctype声明的网页进行怪异模式解析。两者的区别:http://htmljs.b0.upaiyun.com/uploads/1447847078679-d13a9b1cadb6c5eb881c73c015943cb0.png xhtml和html的区别 最主要的不同: XHTML可以理解为html+xml，就是用xml的语法来规范html。 XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 使用data-的好处 可以进行数据存放， 可以解决自定义属性混乱无管理的现状 meta标签 https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta canvas canvas 元素用于在网页上绘制图形http://www.w3school.com.cn/html5/html_5_canvas.asp HTML废弃的标签 &lt;big&gt; &lt;center&gt; &lt;font&gt; &lt;frame&gt; &lt;bgsound&gt; IE6 bug，和一些定位写法 http://www.51xuediannao.com/html+css/htmlcssjq/139.html css js放置位置和原因 css放在head中， 是因为浏览器解析html文档是自上而下的，如果放底部的话，页面结构出来了，css还没开始渲染，可能会看到只有结构的页面。CSS 应当写在 head 中，以避免页面元素由于样式确实造成瞬间的白页或者给用户闪烁感。而js放在之前，是因为JS可能会改变DOM树，也可能依赖css样式。如果放在前面，那么DOM和css可能还加载，这样容易报错。还有一个，我觉得是加载速度的问题，js放前面，页面会先去加载他，拖慢了时间，使用户一定时间内看不到网页内容。 什么是渐进式渲染 渐进式渲染是指浏览器不用等待所有页面资源都渲染好之后再呈现给用户看，而是边下载边渲染，所以用户打开一个网页的时候往往不能第一时间看到所有的内容，但是能够看到一个大概的样子，后续的内容浏览器会慢慢补上形成一个完整的页面 html模板语言 Jade 、Ejs、Swig meta viewport原理 移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中： 12&gt;&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&gt;该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。这个name为viewport的meta标签到底有哪些东西呢，又都有什么作用呢？meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：&gt;|属性|描述||:-|:-||width|设置layout viewport 的宽度，为一个正整数，或字符串&quot;width-device&quot;||initial-scale|设置页面的初始缩放值，为一个数字，可以带小数||minimum-scale|允许用户的最小缩放值，为一个数字，可以带小数||maximum-scale|允许用户的最大缩放值，为一个数字，可以带小数||height|设置layout viewport 的高度，这个属性对我们并不重要，很少使用||user-scalable|是否允许用户进行缩放，值为&quot;no&quot;或&quot;yes&quot;, no 代表不允许，yes代表允许|## CSS(Cascading Styleheet)### 盒模型，box-sizing&gt;HTML文档中的每个元素都被描绘成矩形盒子，盒模型以下内容组成：content+padding+border+margin使用 box-sizing 属性，你可以告诉浏览器元素的宽度中包不包括 padding 和（或）border的宽度box-sizing的参数：content-box（默认） | border-box&gt;|参数|描述||:-|:-||content-box|默认行为。指定的宽度高度（以及相应的 min-width，min-height 和 max-width，max-height 属性）分别适用于元素的内容框的宽度和高度。元素的 padding 和 border 被布置并绘制在指定的宽度和高度之外。元素的指定宽度和高度不包括 padding 和 border。||border-box|此元素上指定的宽度和高度（以及相应的 min-width，min-height 和 max-width，max-height 属性）确定元素的边框。也就是说，元素上指定的任何 padding 或 border 都会在此指定的宽度和高度内进行布局和绘制。通过从指定的 width 和 height 属性中减去各边的 padding 宽度来计算内容宽度和高度。由于内容宽度和高度不能为负，因此该计算的值为 0。也就是说，如果 padding 对于指定的宽度和高度太大，则内容区域的大小可能为零。指定的宽度和高度包括 padding 和 border。|### CSS3新特性，伪类，伪元素，锚伪类&gt;CSS3新特性: https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css3-news.htmlCSS伪类，伪元素: http://www.jianshu.com/p/dcd3ca839e5f### CSS实现隐藏页面的方式&gt;- 将 opacity 设为 0- 将 visibility 设为 hidden- 将 display 设为 none- 将 position 设为 absolute 然后将位置设到不可见区域### 如何实现水平居中和垂直居中。&gt;**水平居中**定宽块级元素- margin: 10px auto;&gt;不定宽块级元素- display: inline;text-align: center;- 为需要设置的居中的元素外面加入一个 table 标签 ( 包括 &lt;tbody&gt;、&lt;tr&gt;、&lt;td&gt; ) 为这个 table 设置“左右 margin:auto”（这个和定宽块状元素的方法一样）。- 通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:-50% 来实现水平居中。&gt;**垂直居中**- display:table； vertical-align: middlel;- 使用绝对定位的 position，把它的 top 设置为 50％，margin-top 设置为负的 content 高度的一半- 在 content 元素外插入一个 div。设置float: left; height:50%；margin-bottom:-contentheight;content 清除浮动,将position设置为relative- 使用了一个 position:absolute，有固定宽度和高度的 div。这个 div 被设置为 top:0; bottom:0;。但是因为它有固定高度，其实并不能和上下都间距为 0，因此 margin:auto; 会使它居中- 只能将单行文本置中。只需要简单地把 line-height 设置为那个对象的 height 值- 使用flex布局### 说说position，display&gt;**position**&gt;|值|属性||:-|:-||static|默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明)||relative|生成相对定位的元素，相对于元素本身正常位置进行定位。因此，&quot;left:20&quot; 会向元素的 LEFT 位置添加 20 像素。||absolute|生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定||fixed|生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定||inhert|规定应该从父元素继承 position 属性的值|&gt;**display**&gt;|值|属性||:-|:-||none|此元素不会被显示||block|此元素将显示为块级元素，此元素前后会带有换行符||inline此元素会被显示为内联元素，元素前后没有换行符||inline-block|行内块元素。（CSS2.1 新增的值）||table|此元素会作为块级表格来显示（类似 `&lt;table&gt;`），表格前后带有换行符||flex|采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&quot;项目&quot;||grid|像表格一样，网格布局允许作者能够将元素对齐到列和行中。 但是，使用CSS网格可能还是比CSS表格更容易布局。 例如，网格容器的子元素可以自己定位，以便它们像CSS定位的元素一样，真正的有重叠和层次|### 请解释*&#123;box-sizing:border-box;&#125;的作用，并说明使用它的好处&gt;可以随意的修改padding和border的厚度值，根本不用担心父容器被撑爆;IE8已经支持border-box，兼容性不是问题### 浮动元素引起的问题和解决办法？绝对定位和相对定位，元素浮动后的display值&gt;1. 父元素高度无法被撑开，影响福缘寺同级的元素2. 与浮动元素同级的非浮动元素会跟随其后3. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面的结构&gt;**解决办法**&gt;使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式&gt;&gt; .clearfix{display:inline-block;}/for ie/mac/.clearfix:after{content:”.”;diaplay:block;height:0;clear:both;vissibility:hiddden}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217```### link和@import引入css的区别&gt;- link属于XHTML标签。而@import完全是CSS提供的一种方式- 当一个页面被加载时，link引用的CSS会被同时加载；而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候@import加载CSS页面时开始好没有样式（造成闪烁）。- 使用JavaScript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的### 解释一下css3的flexbox，以及适用场景&gt;采用 Flex 布局的元素，称为 Flex 容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称&quot;项目&quot;。、容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。-弹性盒子中的子元素可以在各个方向上进行布局，并且能以弹性尺寸来适应显示空间&gt;**适用场景**- 响应式布局- 垂直居中### inline和inline-block的区别&gt;- inline元素设置width,height属性无效;inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果- 将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性### 哪些是块级元素那些是行级元素，各有什么特点&gt;- 块级元素：div、h1~h6、ul、ol。li、table。p... 特点:a.总是在新行上开始b.高度、行高以及外边距和内边距都可控制c.宽度默认是它容器的100%，除非设定一个宽度d.可以容纳其他内联元素和其他块元素- 内联元素：a、img、i、strong、b、input、label、span、textarea... 特点:a.和其他元素都在同一行b.高，行高及内外边距Buena改变c.宽度就是它的文字和图片的宽度，不可改变d.内联元素只能容纳文本或者其他内联元素### grid布局&gt;- https://juejin.im/entry/5894135c8fd9c5a19507f6a1- https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout### table布局的作用&gt;tabel要整个下载完才显示。主要用来显示数据。### 实现两栏布局有哪些方法？&gt;- float+margin-left- absolute+margin-left- 浮动和负边距实现- flex- float+BFChttp://www.jianshu.com/p/b4ba0ef3307a### css dpi&gt;- https://www.zhihu.com/question/19851058- https://www.w3.org/Style/Examples/007/units.zh_CN.html### 你知道attribute和property的区别么&gt;http://joji.me/zh-cn/blog/html-attribute-vs-dom-property### css布局问题？css实现三列布局怎么做？如果中间是自适应又怎么做？&gt;http://blog.csdn.net/cinderella_hou/article/details/52156333### 流式布局如何实现，响应式布局如何实现&gt;- 流式布局：https://www.w3cplus.com/css/pure-css-create-masonry-layout.html- 响应式布局：https://xifengxx.github.io/2016/06/10/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/### 移动端布局方案&gt;https://github.com/imochen/hotcss### 实现三栏布局（圣杯布局，双飞翼布局，flex布局）&gt;- http://www.jianshu.com/p/f9bcddb0e8b4- https://www.zhihu.com/question/21504052### 清除浮动的原理&gt;- http://www.jianshu.com/p/a92d9a79d7e7- http://snailsky.me/2014/08/20/%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%83%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9F/- https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html### padding百分比是相对于父级宽度还是自身的宽度&gt;- 相对于父元素宽度的：[max/min-]width、left、right、padding、margin 等；&gt;- 相对于父元素高度的：[max/min-]height、top、bottom 等；&gt;- 相对于继承字号的：font-size 等；&gt;- 相对于自身字号的：line-height 等；&gt;- 相对于自身宽高的：border-radius、background-size、transform: translate()、transform-origin、zoom、clip-path 等；&gt;- 特殊算法的：background-position（方向长度 / 该方向除背景图之外部分总长度 * 100）、filter 系列函数等；&gt;- 如果自身设置 position: absolute，“父元素”指：[破坏文档流的div高度设为百分比是相对谁而言的？](https://www.zhihu.com/question/35707704/answer/64079391)&gt;- 如果 position: fixed，“父元素”指视口。### css3动画，transition和animation的区别，animation的属性，加速度，重力的模拟实现&gt;- transition和animation的区别：http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html- 加速度：ease-in（低速开始）和ease-out（高速开始）；重力模拟直接用ease-in### CSS 3 如何实现旋转图片&gt;transform: rotate(angle)### Sass Less&gt;- 编译环境不一样：Sass的安装需要Ruby环境，是在服务端处理的；而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中- 变量符不一样：Sass是$,Less是@- Sass支持条件语句，可以使用if&#123;&#125;else&#123;&#125;，for&#123;&#125;循环等等。而Less不支持- 引用文件：Sass引用的外部文件必须以_开头，如`@import &quot;_test.sass&quot;`;文件名如果以下划线开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件。Less引用外部文件和css中的@import什么差异### 对移动端开发了解多少？（响应式设计、Zepto；@media、viewport、JavaScript 正则表达式判断平台。）&gt;- 响应式设计：同一个页面，随着屏幕尺寸的改变，自适应地改变页面布局- zepto：http://www.css88.com/doc/zeptojs_api/- @media ：@media CSS at-rule 将一组嵌套语句关联在由大括号分隔的CSS块中，使用由media query定义的一个条件。@media 规则不仅可以在一个CSS的顶层使用，也可以在任何CSS conditional-group at-rule中使用。https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media- viewport：关于设备窗口表示，分为visual viewport 、layout viewport和ideal viewport。 - visual viewport ：即视觉窗口，可以理解为设备自己的宽度内的区域窗口，对应的是device pixels。 - layout viewport： 虚拟视觉窗口。为了解决移动端正常显示而产生的。 - ideal viewport：用户设置的大小，由`&lt;meta name=&quot;viewport&quot;&gt;`标签决定。在进行移动设备网站的开发时，我们需要的是ideal viewport,使用meta标签- 利用javascript正则表达式判断平台：navigator.platform获取平台。然后创建正则表达式，然后用test方法进行判断### 什么是bfc，如何创建bfc？解决什么问题？&gt;- 创建bfc的方法：a.display:table，前后带有换行符，一般不常用；b.overflow:scroll,可能出现不想要的滚动条；c.float:left,万一我盟不想让元素浮动呢；d.overflow:hidden，比较完美的创建bfc的方案，副作用较小。- bfc能解决的问题：a.解决margin collapse（外边距叠加）b.清除浮动 c.实现两栏布局- https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html- https://x-front-team.github.io/2017/02/19/CSS%E4%B8%AD%E7%9A%84BFC/### CSS中的长度单位（px,pt,rem,em,ex,vw,vh,vh,vmin,vmax）&gt;https://www.w3cplus.com/css/the-lengths-of-css.html### CSS 选择器的优先级是怎样的？&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity### 雪碧图&gt;- 雪碧图本质上就是将众多图片拼贴为一张作为背景图片引用,然后通过background-position属性来设置要显示的图片的位置，从而达到显示图片的效果- https://juejin.im/post/58eb062861ff4b006b576d9c### svg&gt;- w3c的svg教程：https://www.w3schools.com/graphics/svg_intro.asp- svg的动画实践：https://75team.com/post/svg-animation-in-action.html### 媒体查询的原理是什么？&gt;W3School的CSS3 媒体查询：https://www.w3schools.com/css/css3_mediaqueries.asp### CSS 的加载是异步的吗？表现在什么地方？&gt;- 不是。在所有的css文件加载完之前，浏览器无法渲染任何内容（也就是白屏）。- 一种新的css加载方式：http://blog.shaochuancs.com/new-css-loading-method/### 常遇到的浏览器兼容性问题有哪些？常用的hack的技巧&gt;浏览器的兼容性？！:http://www.jianshu.com/p/a1f237dacf5b### 外边距合并&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing### 解释一下“::before”和“:after”中的双冒号和单冒号的区别&gt;- 伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素.- http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/### CSS矩阵&gt;http://hcysun.me/2017/05/13/%E4%BB%8E%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%93%8D%E4%BD%9C%E7%9A%84%E5%85%B3%E7%B3%BB%E7%90%86%E8%A7%A3CSS3%E7%9A%84transform/## JS(JavaScript)### js的基本类型有哪些？引用类型有哪些？null和undefined的区别。&gt;- 基本类型：Boolean、Null、Undefined、Number、String、Symbol（ECMAScript-6新定义）- 引用类型：Object、Array、Date、RegExp、Function等- null和undefined的区别：null表示&quot;没有对象&quot;，即该处不应该有值；undefined表示缺少值，就是此处应该有一个值，但是还没有定义。- undefined和null的区别：http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html### 如何判断一个变量是Array类型？如何判断一个变量是Number类型？（都不止一种）&gt;- instanceof(x)===Array为true；x.constractor===Array;Object.prototype.tostring.call(x)===&apos;[object Array]&apos;(注意：对数组使用typeof，返回的是object)- https://segmentfault.com/a/1190000004479306### Object是引用类型嘛？引用类型和基本类型有什么区别？哪个是存在堆哪一个是存在栈上面的？&gt;- object和string都是只读对象，引用类型。- 基本类型和引用类型的区别：基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值；引用类型可以拥有属性和方法，属性又可以包含基本类型和引用类型。- 基本类型是存放在栈区的，栈区包括了变量的标识符和变量的值；引用类型的存储需要内存的栈区和堆区共同完成，栈区内存保存变量标识符和指向对内存中该对象的指针，堆区保存该对象的值。### JS常见的dom操作api&gt;http://www.cnblogs.com/liuxianan/p/javascript-dom-api.html### 解释一下事件冒泡和事件捕获&gt;https://segmentfault.com/a/1190000005654451### 事件委托（手写例子），事件冒泡和捕获，如何阻止冒泡？如何阻止默认事件？&gt;- 事件委托：把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。- https://zhuanlan.zhihu.com/p/26536815- 如何阻止冒泡：w3c的方法是e.stopPropagation(),IE则是e.cancelBubble=true.在支持addEventListener()的浏览器中，也能通过调用事件对象的一个stopPropagation()方法以阻止事件的继续传播。- 如何阻止默认事件：w3c的方法是e.preventDefault(),IE则是e.returnVaule=false.在支持addEventListener()的浏览器中，也能通过调用事件对象的preventDefault()方法取消事件的默认操作。### 对闭包的理解？什么时候构成闭包？闭包的实现方法？闭包的优缺点？&gt;- 函数内部的局部变量只有函数内部的子函数才可以读取，可如果在函数的返回值上返回一个调用局部变量的函数的话，就可以实现把函数内部的局部变量传递出去。所以在本质上，可以说闭包就是讲函数内部和函数外部链接起来的一座桥梁。- 深入贯彻闭包思想，全面理解JS闭包形成过程：https://segmentfault.com/a/1190000009886713- 闭包的最大用处有两个，一个是前面提到的可以读取行距是内部的局部变量，另一个就是让这些变量的值始终保持在内存中。过度使用闭包的话可能会造成内存消耗过多。### this有哪些使用场景？跟C,Java中的this有什么区别？&gt;- JavaScript中this的用法：http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html### call，apply，bind&gt;- 相似：1.都是用来改变函数的this对象的指向的。2.第一个参数都是this要指向的对象。3.都可以利用后续参数传参。- call：obj1.sayname.call(obj2,&apos;女&apos;,167);call后面的参数跟sayname方法的参数中是一一对应。- bind：bind可以像call一样传参，不过返回的仍然是一个函数，因此后面还需要()来进行调用才可以。- apply：apply的第二个参数可以是一个数组，数组中的元素和sayname方法中的参数一一对应。### 显式原型和隐式原型，手绘原型链，原型链是什么？为什么要有原型链&gt;- JavaScript中的显式原型和隐式原型：https://zhuanlan.zhihu.com/p/23253365- 原型链是什么：每个对象都有一个私有属性`__proto__`，它持有连接到一个称为prototype对象(原型对象)的链接，这一条条的链接所形成的链就叫做原型链- 手绘原型链：![](https://camo.githubusercontent.com/fd85b2019f0a291907fe647d195ba45d8db4ea24/687474703a2f2f6f73387067326a78612e626b742e636c6f7564646e2e636f6d2f50726f746f74797065322e706e67)- 原型链的作用：### 创建对象的多种方式&gt;- JavaScript创建对象的7种方法：https://juejin.im/entry/58291447128fe1005cd41c52### 实现继承的多种方式和优缺点&gt;JS继承的实现方式：http://www.cnblogs.com/humin/p/4556820.html### new 一个对象具体做了什么&gt;要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：（1）创建一个新对象；（2）将构造函数的作用域赋给新对象（因此this就指向了这个对象）；（3）执行构造函数中的代码（为这个新对象添加属性）；（4）返回新对象&gt; function Person(name){ this.name = name; };}function newFunc(name){ var o = {}; o.proto = Person.prototype;//绑定Person的原型 Person.call(o, name); return o;}1234### 手写Ajax，XMLHttpRequest&gt; var xmlhttp=null;//声明一个变量，用来实例化XMLHttpRequest对象if (window.XMLHttpRequest){xmlhttp=new XMLHttpRequest();// 新版本的浏览器可以直接创建XMLHttpRequest对象}123456789101112131415161718192021222324252627282930313233else if (window.ActiveXObject) &#123; xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);// IE5或IE6没有XMLHttpRequest对象，而是用的ActiveXObject对象 &#125;if (xmlhttp!=null) &#123; xmlhttp.onreadystatechange=state_Change;//指定响应函数为state_Change xmlhttp.open(&quot;GET&quot;,&quot;/example/xdom/note.xml&quot;,true);//指定请求，这里要访问在/example/xdom路径下的note.xml文件，true代表的使用的是异步请求 xmlhttp.send(null);//发送请求 &#125; else &#123; alert(&quot;Your browser does not support XMLHTTP.&quot;); &#125;//创建具体的响应函数state_Changefunction state_Change()&#123;if (xmlhttp.readyState==4) &#123; if (xmlhttp.status==200)​ &#123;​ // 这里应该是函数具体的逻辑​ &#125; else​ &#123;​ alert(&quot;Problem retrieving XML data&quot;);​ &#125; &#125;&#125; 创建XMLHttpRequest对象 指定响应函数 打开连接（指定请求) 发送请求 创建响应函数） 变量提升 简单来说，就是把变量的声明提升至前边,被提升的变量初始值为undefined，执行到所在行时才真正赋值。还有就是函数提升，函数的提升和变量提升一样，都是声明的提升，函数提升允许我们把函数定义在代码的任意位置都可以调用。 举例说明一个匿名函数的典型用例 12345678910111213function()&#123; return function()&#123; &#125;&#125;const func = function()&#123;&#125;(function()&#123;&#125;)() 指出JS的宿主对象和原生对象的区别，为什么扩展JS内置对象不是好的做法？有哪些内置对象和内置函数？ 为什么扩展内置对象不是好的做法：a.容易造成全局污染，和其他库冲突 b.出了Bug不太好定位问题 c.有可能出现代码向上不兼容的情况，比如定义了一个Object.prototype.clone。万一ES7、ES8也定义了这个函数，那旧代码不就会出现问题了嘛！https://www.zhihu.com/question/26924011 内置对象：https://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html-内置函数：http://wiki.jikexueyuan.com/project/javascript/function.html attribute和property的区别 http://joji.me/zh-cn/blog/html-attribute-vs-dom-property document load和document DOMContentLoaded两个事件的区别 区别是:触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。DOM文档加载的步骤为： 解析HTML结构。 DOM树构建完成。//DOMContentLoaded 加载外部脚本和样式表文件。 解析并执行脚本代码。 加载图片等外部文件。 页面加载完毕。//load 在第2步，会触发DOMContentLoaded事件。在第6步，触发load事件。 === 和 == , [] === [], undefined === undefined,[] == [], undefined == undefined 红色：===橙色：==黄色：&lt;= 和 &gt;= 同时成立，== 不成立蓝色：只有 &gt;=绿色：只有 &lt;= typeof能够得到哪些值 typeof undefined // undefinedtypeof ‘abc’ //stringtypeof ‘123’ //numbertypeof true //booleantypeof {} //objecttypeof [] //objecttypeof null //objecttypeof console.log //function 什么是“use strict”,好处和坏处 JavaScript中的with关键字：http://luopq.com/2016/02/14/js-with-keyword/ JavaScript严格模式详解：http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html 好处：1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 坏处：现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge (合并)后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 函数的作用域是什么？js 的作用域有几种？ 函数作用域：函数内部的对象、变量、函数的作用范围 全局作用域，函数作用域、严格模式下的eval作用域 JS如何实现重载和多态 js函数重载：https://blog.fundebug.com/2017/07/24/javascript_metho_overloading/ js实现多态：多态就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 123456789101112131415var makeSound = function(animal) &#123; animal.sound();&#125;var Duck = function()&#123;&#125;Duck.prototype.sound = function() &#123; console.log(&apos;嘎嘎嘎&apos;)&#125;var Chiken = function() &#123;&#125;;Chiken.prototype.sound = function() &#123; console.log(&apos;咯咯咯&apos;)&#125;makeSound(new Chicken());makeSound(new Duck()); 常用的数组api，字符串api 常用数组apiforEach():遍历数组的所有元素every():用来判断所有的数组元素，都满足一个条件some():用来判断所有的数组元素，只要有一个满足条件即可sort(func):按指定的战术对数组排序map():将元素重新组装，并返回filter():通过某一条过滤数组concat():连接两个或多个数组，并返回结果join(str):把数组的所有元素用str分隔，默认逗号分隔pop():删除并返回数组的最后一个元素的值push():向数组的末尾添加一个或更多元素，并返回新的数组长度reverse():返祖数组中的元素的顺序，并返回新的数组shift():删除并返回数组的第一个元素unshift():讲指定元素插入数组开始位置，并返回新的长度slice(start,end):从已有的数组中返回选定的元素splice(start,deleteCount,val1,val2,...):从一个数组中一处一个或多个元素，并在该位置插入新元素，返回所移除的元素toString():将数组的元素转换为字符串，并用逗号分隔，且连接起来 常用字符串apicharAt(index):用来获取指定位置的字符串，index为字符串索引值，取值范围为0到string.length-1，若不在这个范围将返回一个空字符串charCodeAt():可返回指定位置的字符的Unicode编码。用法和charAt()类似indexOf(searchvalue,fromindex):用来检索指定的字符串在字符串中首次出现的位置，它可以接受两个参数，searchvalue表示要查找的子字符串，fromindex表示查找的开始位置，省略的话则从开始位置进行检索lastIndexOf(searchvalue,fromindex):语法和indexOf()类似，它返回的是一个指定的子字符串值最后出现的位置，其检索顺序是从后向前search():用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。它会返回第一个匹配的子字符串的起始位置，如果没有匹配的，则返回-1match():可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配substring(start,[end]):截取从start到end-1出的所在字符。若结束参数省略，则表示从start位置一直截取到最后slice(start,[end]):与substring()方法非常类似，区别在于，slice()中的参数可以为负值，如果参数是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1指字符串的最后一个字符substr(start,[length]):可在字符串中抽身从start下标开始的指定的字符。其返回值为一个字符串，包含中stringObject的start(包括start所指的字符)处开始的length个字符。如果没有指定length，那么返回的字符串包含从start到stringObject的结尾的字符。另外如果start为负数，则表示中字符串的尾部开始算起。replace(reg/substr,repalcement):用来进行字符串替换操作，它课程接收两个参数，前者为被替换的子字符串（可以是正则），后者为用来替换的文本spilt(separator，howmany):用于把一个字符串分割成字符串数组。第一个参数separator表示分割符号，第二个参数howmany表示返回数组的允许最大长度（一般情况下不设置)。toLowerCase()、toUpperCase():可以把字符串中的大/小写字母转换为小/大写字母 原生事件绑定（跨浏览器），dom0和dom2的区别？ 原生JavaScript事件详解：http://www.cnblogs.com/iyangyuan/p/4190773.html dom0和dom2的区别：DOM2支持同一dom元素注册多个同种事件。DOM2新增了捕获和冒泡的概念。 给定一个元素获取它相对于视图窗口的坐标 用Javascript获取页面元素的位置：http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html 如何实现图片滚动懒加载 js实现一个图片的懒加载插件；http://www.zyy1217.com/2017/03/20/js%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6/ 高性能滚动scroll及页面渲染优化原理与实例：http://www.zyy1217.com/2017/03/16/%E9%AB%98%E6%80%A7%E8%83%BD%E6%BB%9A%E5%8A%A8%20scroll%20%E5%8F%8A%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/ 正则表达式的函数怎么使用？ test(): 检测字符串中的指定。返回值是true或false exec(): 检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回null compile(): 用于改变RegExp。既可以改变检索模式，也可以添加或删除第二个参数。http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp 深拷贝 对于字符串类型，浅复制是对值的复制，对于对象来说，浅复制是对对象地址的复制，并没 有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变，而深复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。https://www.zhihu.com/question/23031215 编写一个通用的事件监听函数 123456789101112131415161718&gt;// event(事件)工具集，来源：github.com/markyun&gt;markyun.Event = &#123;&gt;// 页面加载完成后&gt;readyEvent : function(fn) &#123;&gt;if (fn==null) &#123;&gt;fn=document;&gt;&#125;&gt;var oldonload = window.onload;&gt;if (typeof window.onload != &apos;function&apos;) &#123;&gt;window.onload = fn;&gt;&#125; else &#123;&gt;window.onload = function() &#123;&gt;oldonload();&gt;fn();&gt;&#125;;&gt;&#125;&gt;&#125;,&gt; // 视能力分别使用dom0||dom2||IE方式 来绑定事件// 参数： 操作的元素,事件名称 ,事件处理程序addEvent : function(element, type, handler) {if (element.addEventListener) {//事件类型、需要执行的函数、是否捕捉element.addEventListener(type, handler, false);} else if (element.attachEvent) {element.attachEvent(‘on’ + type, function() {handler.call(element);});} else {element[‘on’ + type] = handler;}}, // 移除事件removeEvent : function(element, type, handler) {if (element.removeEventListener) {element.removeEventListener(type, handler, false);} else if (element.datachEvent) {element.detachEvent(‘on’ + type, handler);} else {element[‘on’ + type] = null;}}, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)stopPropagation : function(ev) {if (ev.stopPropagation) {ev.stopPropagation();} else {ev.cancelBubble = true;}}, // 取消事件的默认行为preventDefault : function(event) {if (event.preventDefault) {event.preventDefault();} else {event.returnValue = false;}}, // 获取事件目标getTarget : function(event) {return event.target || event.srcElement;}, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；getEvent : function(e) {var ev = e || window.event;if (!ev) {var c = this.getEvent.caller;while (c) {ev = c.arguments[0];if (ev &amp;&amp; Event == ev.constructor) {break;}c = c.caller;}}return ev;}};123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142### web端cookie的设置和获取&gt;聊一聊cookie：https://segmentfault.com/a/1190000004556040### setTimeout和promise的执行顺序&gt;Promise的队列和setTimeOut的队列有何关联？：https://www.zhihu.com/question/36972010### JavaScript 的事件流模型都有什么？&gt;- 事件冒泡：事件开始由最具体的元素接受，然后逐级向上传播- 事件捕获：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的- dom事件流：分为三个阶段：事件捕获、目标阶段、事件冒泡https://juejin.im/entry/5826ba9d0ce4630056f85e07### navigator对象，location和history&gt;http://blog.csdn.net/gavin_john/article/details/21738675### 内存泄漏的原因和场景&gt;JavaScript中的内存泄漏问题https://octman.com/blog/2016-06-28-four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/### js的垃圾回收机制&gt;大部分浏览器使用是标记清除，旧版ie使用的是引用计数，引用计数不能清除循环https://segmentfault.com/a/1190000008594652### DOM事件的绑定的几种方式&gt;- 在DOM中，直接用onXXX=&quot;fun();&quot;进行绑定- 在Javascript代码中用 DOM对象.onXXX=fun 进行绑定- 用 DOM对象.addEventListener(&quot;onXXX&quot;,fun[,boolean]) 进行绑定- 用&lt;script for=&quot;domId&quot; event=&quot;onXXX&quot;&gt;fun();&lt;/script&gt; 进行绑定### DOM事件中target和currentTarget的区别&gt;e.currentTarget始终指向添加监听事件的那个对象，而e.target指向触发事件监听的那个对象https://plainnany.github.io/2017/07/06/e-target%E4%B8%8Ee-currentTarget%E7%9A%84%E5%8C%BA%E5%88%AB/### typeof 和 instanceof 区别，instanceof原理&gt;- typeoftypeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。它返回值是一个字符串，该字符串说明运算数的类型。typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。我们可以使用 typeof 来获取一个变量是否存在，如 if(typeof a!=&quot;undefined&quot;)&#123;alert(&quot;ok&quot;)&#125;，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错，对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。&gt;&gt;- instanceofinstance：实例,例子a instanceof b?alert(&quot;true&quot;):alert(&quot;false&quot;); //a是b的实例？真:假instanceof 用于判断一个变量是否某个对象的实例，如 var a=new Array();alert(a instanceof Array);会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object的子类。再如：function test()&#123;&#125;;var a=new test();alert(a instanceof test) 会返回谈到 instanceof 我们要多插入一个问题，就是 function 的 arguments，我们大家也许都认为 arguments 是一个Array，但如果使用 instaceof 去测试会发现 arguments 不是一个 Array 对象，尽管看起来很像。另外：测试 var a=new Array();if (a instanceof Object) alert(&apos;Y&apos;);else alert(&apos;N&apos;);得&apos;Y&apos;但 if (window instanceof Object) alert(&apos;Y&apos;);else alert(&apos;N&apos;);得&apos;N&apos;所以，这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。使用 typeof 会有些区别。alert(typeof(window)) 会得 object### js动画和css3动画比较&gt;- **JS动画**优点：JavaScript的动画与CSS预先定义好的动画不同，可以在其动画过程中对其进行控制：开始、暂停、回放、中止、取消都是可以做到的。而且一些动画效果，比如视差滚动效果，只有JavaScript能够完成缺点：JavaScript在浏览器的主线程中运行，而其中还有很多其他需要运行的JavaScript、样式计算、布局、绘制等对其干扰。这也就导致了线程可能出现阻塞，从而造成丢帧的情况。- **CSS动画**优点：浏览器可以对动画进行优化。它必要时可以创建图层，然后在主线程之外运行。缺点：缺乏强大的控制能力。而且很难以有意义的方式结合到一起，使得动画变得复杂且易于出问题。&gt;&gt;https://segmentfault.com/q/1010000000645415### JavaScript 倒计时（setTimeout）&gt;setTimeout(code,millisec)方法用于在指定的毫秒数后调用函数或计算表达式。### js处理异常&gt;JavaScript中的异常处理：https://segmentfault.com/a/1190000011481099### js的设计模式知道那些&gt;设计模式分类（创建型模式、结构型模式、行为模式），这是重点，一开始我也不明白设计模式，从头看到尾，直到有点有个高人指点，我才发现这3个玩意，他们又对应不同的设计模式。&gt;创建型模式社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：&gt;简单工厂模式（Simple Factory）工厂方法模式（Factory Method）抽象工厂模式（Abstract Factory）创建者模式（Builder）原型模式（Prototype）单例模式（Singleton）&gt;结构型模式在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：&gt;外观模式/门面模式（Facade门面模式）适配器模式（Adapter）代理模式（Proxy）装饰模式（Decorator）桥梁模式/桥接模式（Bridge）组合模式（Composite）享元模式（Flyweight）&gt;行为型模式在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：&gt;模板方法模式（Template Method）观察者模式（Observer）状态模式（State）策略模式（Strategy）职责链模式（Chain of Responsibility）命令模式（Command）访问者模式（Visitor）调停者模式（Mediator）备忘录模式（Memento）迭代器模式（Iterator）解释器模式（Interpreter）&gt;举个栗子比如观察者模式 又叫发布订阅者模式，前端很常用的模式，自定义事件，数据监听。mvvm框架里面都有这个玩意。组件之间数据交互，都会用到这个东西。细谈JavaScript中的一些设计模式：https://segmentfault.com/a/1190000004568177### 轮播图的实现，以及轮播图组件开发，轮播10000张图片过程&gt;四种方式实现轮播图：http://www.jianshu.com/p/bd1f34e7e953### websocket的工作原理和机制。&gt;websocket是什么原理？：https://www.zhihu.com/question/20215561### 手指点击可以触控的屏幕时，是什么事件？&gt;移动端常见的触摸相关事件touch、tap、swipe等整理：http://www.cnblogs.com/imwtr/p/5882166.html### 什么是函数柯里化？以及说一下JS的API有哪些应用到了函数柯里化的实现？(函数柯里化一些了解，以及在函数式编程的应用，最后说了一下JS中bind函数和数组的reduce方法用到了函数柯里化。)&gt;柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数同时也返回结果的新函数的技术。JS中的柯里化(currying)：http://www.zhangxinxu.com/wordpress/2013/02/js-currying/### JS代码调试&gt;Chrome 控制台 如何调试 javascript：https://segmentfault.com/a/1190000002507480## ES6(ECMAscript-6)### 谈一谈 promise&gt;Promise对象代表一个目前还不可用，但是在未来的某个时间点可以被解析的值。它允许你以一种同步的方式去编写异步代码。例如，如果你想要使用Promise API异步调用一个远程的服务器，你需要创建一个代表数据将会在未来由web服务返回的Promise对象。唯一的问题是目前数据还不可用。当请求完成并从服务器返回时数据将变为可用数据。在此期间，Promise对象将扮演一个真实的数据代理角色。接下来，你可以在Promise对象上绑定一个回调函数，一旦真实数据变得可用这个回调函数将会被调用。Promise对象在new了之后立即执行。深入浅出谈Promise：http://www.jianshu.com/p/92fa1de26f05### 所有的 ES6 特性你都知道吗？如果遇到一个东西不知道是 ES6 还是 ES5, 你该怎么区分它&gt;es6新特性总结：http://imweb.io/topic/55e330d6771670e207a16bbb### es6的继承和es5的继承有什么区别&gt;- ES5中的继承是子构造函数的原型(Sub.prototype.\\_\\_proto\\_\\_)指向父构造函数的原型(Super.prototype)；子构造函数的实例(sub.\\_\\_proto\\_\\_)指向子构造函数的原型(Sub.prototype)- ES6中的继承是子类(Sub.\\_\\_proto\\_\\_)指向父类(Super);子类的原型(Sub.prototype.\\_\\_proto\\_\\_)指向父类的原型(Super.prototype);子类(sub.\\_\\_proto\\_\\_)的实例指向子类的原型(Sub.prototype)&gt;&gt;ES5和ES6中的继承：http://keenwon.com/1524.html### promise封装ajax&gt;**GET**&gt; function getJSON (url) { return new Promise( (resolve, reject) =&gt; { var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;, url, true) xhr.onreadystatechange = function () { if (this.readyState === 4) { if (this.status === 200) { resolve(this.responseText, this) } else { var resJson = { code: this.status, response: this.response } reject(resJson, this) } } } xhr.send() }) }1234&gt;**POST**&gt; function postJSON(url, data) { return new Promise( (resolve, reject) =&gt; { var xhr = new XMLHttpRequest() xhr.open(“POST”, url, true) xhr.setRequestHeader(“Content-type”, “application/x-www-form-urlencoded”);123456789101112131415 xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(JSON.parse(this.responseText), this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)) &#125;)&#125; let const的优点 避免内层变量覆盖外层变量 避免用来计数的循环变量泄漏为全局变量 引入了块级作用域，允许块级作用域之中声明函数 es6 generator 是什么，async/await 实现原理 Generator函数是ES6提供的一种异步编程解决方案，与发行未与传统函数完全不同。Generator函数有多种理解角度。语法上，首先可以把它理解成一个状态机，封装了多个内部状态。执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）。async函数是Generator的语法糖。将号换为async，将yield换为awaitGenerator函数的语法：http://es6.ruanyifeng.com/#docs/generatorasync函数的含义和用法：http://www.ruanyifeng.com/blog/2015/05/async.html ES6和node的commonjs模块化规范区别 commonjs是使用require/exports组合来实现的，ES6是使用import/exports组合来实现的。在不完全支持ES6的浏览器中，import/exports最终会被编译成require/exports来执行的。ES6模块和Commonjs的区别：https://wmaqingbo.github.io/blog/2017/09/15/ES6%E6%A8%A1%E5%9D%97-%E5%92%8C-CommonJS-%E7%9A%84%E5%8C%BA%E5%88%AB/ 箭头函数，以及它的this 箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定箭头函数：https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000 babel是如何将es6代码编译成es5的 Babel是如何读懂JS代码的：https://zhuanlan.zhihu.com/p/27289600 计算机网络网络分层模型 OSI七层与TCP/IP五层网络架构详解：http://www.ha97.com/3215.html HTTP协议头含有哪些重要的部分，HTTP状态码 一篇比较全的HTTP协议详解：http://caibaojian.com/http-protocol.html 网络url输入到输出怎么做？1）把URL分割成几个部分：协议、网络地址、资源路径。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。例如：http://www.guokr.com/question/554991/协议部分：http网络地址：www.guokr.com资源路径：/question/554991/2）如果地址不是一个IP地址，通过DNS（域名系统）将该地址解析成IP地址。IP地址对应着网络上一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP。例如：www.guokr.com 不是一个IP，向DNS询问请求www.guokr.com 对应的IP，获得IP： 111.13.57.142。这个过程里，你的电脑直接询问的DNS服务器可能没有www.guokr.com 对应的IP，就会向它的上级服务器询问，上级服务器同样可能没有，就依此一层层向上找，最高可达根节点，找到或者全部找不到为止。3）如果地址不包含端口号，根据协议的默认端口号确定一个。端口号之于计算机就像窗口号之于银行，一家银行有多个窗口，每个窗口都有个号码，不同窗口可以负责不同的服务。端口只是一个逻辑概念，和计算机硬件没有关系。例如：www.guokr.com 不包含端口号，http协议默认端口号是80。如果你输入的url是http://www.guokr.com:8080/ ，那表示不使用默认的端口号，而使用指定的端口号8080。4）向2和3确定的IP和端口号发起网络连接。例如：向111.13.57.142的80端口发起连接5）根据http协议要求，组织一个请求的数据包，里面包含大量请求信息，包括请求的资源路径、你的身份例如：用自然语言来表达这个数据包，大概就是：请求 /question/554991/ ，我的身份是xxxxxxx。6）服务器响应请求，将数据返回给浏览器。数据可能是根据HTML协议组织的网页，里面包含页面的布局、文字。数据也可能是图片、脚本程序等。现在你可以用浏览器的“查看源代码”功能，感受一下服务器返回的是什么东东。如果资源路径指示的资源不存在，服务器就会返回著名的404错误。7）如果（6）返回的是一个页面，根据页面里一些外链的URL，例如图片的地址，按照（1）－（6）再次获取。8）开始根据资源的类型，将资源组织成屏幕上显示的图像，这个过程叫渲染，网页渲染是浏览器最复杂、最核心的功能。9）将渲染好的页面图像显示出来，并开始响应用户的操作。以上只是最基本的步骤，实际不可能就这么简单，一些可选的步骤例如网页缓存、连接池、加载策略、加密解密、代理中转等等都没有提及。即使基本步骤本身也有很复杂的子步骤，TCP/IP、DNS、HTTP、HTML：每一个都可以展开成庞大的课题，而浏览器的基础——操作系统、编译器、硬件等更是一个比一个复杂。不是计算机专业的同学看了上面的解释完全不明白是很正常的，可能会问为什么要搞得那么复杂，但我保证这每一个步骤都经过深思熟虑和时间的考验。你输入URL即可浏览互联网，而计算机系统在背后做了无数你看不到的工作，计算机各个子领域无数工程师为此付出你难以想象的努力。 性能优化为什么要减少 HTTP 访问次数？ 终端用户响应的时间中，有80%用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、Flash等。通过减少页面中的元素可以减少 HTTP请求的次数。这是提高网页速度的关键步骤。尽量减少HTTP请求次数:http://www.dabaoku.com/jiaocheng/tuiguang/youhua/201102248959.shtml Http请求的过程与原理 用户通过客户端向服务端发起一个请求，创建一个TCP连接，指定端口号，默认是80，然后连接到服务器工作。在那个端口监听浏览器请求。一旦监听到客户端请求，分析请求类型后，服务器会向客户端返回一个响应状态，比如”HTTP/1.0 404 OK”，同时会返回特定的数据内容，如请求的资源，错误代码，其它状态信息等等。HTTP请求.原理：http://www.jianshu.com/p/a27f91c51a8b http有几次挥手和握手？TLS的中文名？TLS在哪一网络层？因为HTTP是一个基于TCP的协议,而TCP是一种可靠的传输层协议.建立TCP连接时会发生:三次握手(three-way handshake)firefox &gt; nginx [SYN] 在么nginx &gt; firefox [SYN, ACK] 在firefox &gt; nginx [ACK] 知道了关闭TCP连接时会发生:四次挥手(four-way handshake)firefox &gt; nginx [FIN] 我要关闭连接了nginx &gt; firefox [ACK] 知道了,等我发完包先nginx &gt; firefox [FIN] 我也关闭连接了firefox &gt; nginx [ACK] 好的,知道了几个报文的标识的解释:SYN: synchronization(同步)ACK: acknowledgement(确认:告知已收到)FIN: finish(结束)在HTTP/1.1中,keep-alive能够复用TCP连接,减少TCP三次握手的次数,从而提升性能.结合到PHP编程中,拿Swoole引擎内置的异步HTTP服务器来说说:调用 $res-&gt;end() 将结束HTTP请求,但不会关闭HTTP连接,因为Swoole支持keep-alive.调用 $serv-&gt;close($res-&gt;fd) 将关闭HTTP连接.这种ack确认机制在应用逻辑开发上也是很有用的,比如你用PHP+Swoole开发一个即时通讯软件,要确保不丢消息,要做到:A &lt;=&gt; Server &lt;=&gt; BA发送消息给B后,如果A在指定时间内没有收到Server的消息通知,那么A就要超时重发. 正常情况下,Server收到A的消息后推送给B,B收到消息后通知Server,Server再通知A. 当然,A的超时重发可能会导致B收到重复的消息,所以B接受消息时要进行去重.如果要考察HTTP,我觉得问下HTTP请求/响应报文的组成可能会更好.HTTP请求报文组成:请求行+请求头+请求体HTTP响应报文组成:响应行+响应头+响应体请求行: 请求方法(HEAD/GET/POST) + 请求URL + HTTP协议版本响应行: HTTP协议版本 + 状态码 + 状态码描述请求头: 比如客户端的Cookie和User-Agent就放在这里.响应头: 比如服务器的Set-Cookie和Server信息就放在这里.请求体: 比如客户端POST的数据就放在这里(对比:GET的数据放在请求行的URL里).响应体: 比如服务器返回的HTML和JSON数据就放在这里.curl -I http://mysitecurl这样发起的HTTP请求的请求方法(request_method)就是HEAD,可以这样查看:PHP-FPM: header(“请求方法: $_SERVER[‘REQUEST_METHOD’]”);Swoole: $res-&gt;header(‘请求方法’, $req-&gt;server[‘request_method’]);TSL的中文名字：传输层安全协议，所在层级为传输层TCP协议的三次握手和四次挥手：http://uule.iteye.com/blog/2213562 https有几次握手和挥手？https的原理。 TTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。HTTPS的工作原理：http://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html TCP连接的特点，TCP连接如何保证安全可靠的？ 特点： 应用数据被分割成TCP认为最适合发送的数据块，由TCP传递给IP的信息单位成为报文段或段。·当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。·当TCP收到法子TCP链接另一端的数据，它将发送一个确认，这个确认不是立即发送，通常将推迟几分之一秒。·TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传送过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段(希望发送端超时重发)。·既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排列，将收到的数据以正确的顺序交给应用层。·既然IP数据报会重复发送，TCP的接收端必须丢弃重复的数据(因为会超时重发)·TCP还能提供流量控制。TCP链接的每一方都有固定大小的缓冲控件。TCP的接收端允许另一端发送接受端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。 通过以上特点，TCP会保证发送端应用层的数据正确，准确，按次序到达目的端应用层。详解TCP协议的服务特点以及连接建立与终止的过程(俗称三次握手四次挥手):http://blog.csdn.net/sahadev_/article/details/50780825 可靠性总结： 数据截断为数据报的长度计时重传推迟验证重新排序舍弃重复数据流量控制 TCP如何保证可靠传输：http://blog.csdn.net/smilesundream/article/details/74990214 为什么tcp要三次握手四次挥手？ TCP为什么需要3次握手，4次挥手：http://blog.csdn.net/xifeijian/article/details/12777187 tcp的三次握手和四次挥手画图（当场画写ack 和 seq的值）？ 三次握手： 四次挥手： TCP与UDP的区别 TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。 UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。TCP和UDP此件的区别：http://www.cleey.com/blog/single/id/755.html get和post的区别？什么情况下用到？ HTTP协议中GET和POST方法的区别：https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/ http2 与http1 的区别？ HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。面试时如何优雅的谈论HTTP/1.0/1.1/2.0：http://www.jianshu.com/p/52d86558ca57 websocket websocket是什么原理？：https://www.zhihu.com/question/20215561 什么是tcp流，什么是http流流式传输的两大主流种类及流式传输特点流式传输定义很广泛，现在主要指通过网络传送媒体（如视频、音频）的技术总称。其特定含义为通过Internet 将影视节目传送到PC机。实现流式传输有两种方法：实时流式传输（Realtime streaming）和顺序流式传输（progressive streaming）。（百度百科）在网络上传输音/视频（英文缩写A/V）等多媒体信息目前主要有下载和流式传输两种方案。A/V文件一般都较大，所以需要的存储容量也较大；同时由于网络带宽的限制，下载常常要花数分钟甚至数小时，所以这种处理方法延迟也很大。流式传输时，声音、影像或动画等时基媒体由音视频服务器向用户计算机的连续、实时传送，用户不必等到整个文件全部下载完毕，而只需经过几秒或十数秒的启动延时即可进行观看。当声音等时基媒体在客户机上播放时，文件的剩余部分将在后台从服务器内继续下载。流式不仅使启动延时成十倍、百倍地缩短，而且不需要太大的缓存容量。流式传输避免了用户必须等待整个文件全部从Internet上下载才能观看的缺点。1.流式传输的种类网络传输音频、视频等多媒体信息有下载和流式传输两种方案，下载方案由于A/V文件较大，所需存储容量也较大，且网络带宽的限制导致下载费时久，且延迟亦较大；而流式传输方案则避免了用户需等待整个文件全部下载后才能播放的缺点。流式传输技术又分两种，一种是顺序流式传输，另一种是实时流式传输。①顺序流式传输(Progressive Streaming)顺序流式传输是顺序下载，媒体在下载文件的同时，用户可以观看在线节目。在给定时刻，用户只能观看已下载的那部分，而不能跳到还未下载的部分。顺序流式传输不像实时流式传输那样，可以在传输期间根据用户连接的速度进行调整。由于标准的HTTP服务器可发送这种形式的文件，也不需要其他特殊协议，因而它经常被称作HTTP流式传输。由于该文件在播放前观看的部分是无损下载的，最终播放质量较好，因而特别适合质量较高、数据量较小、通过Modem发布的短片段，如片头、片尾、广告等。但用户在观看前必须经历数秒的延迟，传输速度较慢时尤为明显。对通过调制解调器发布的短片段，顺序流式传输显得很实用，它允许用比调制解调器更高的数据速率创建视频片段。尽管有延迟，毕竟可发布较高质量的视频片段。顺序流式文件是放在标准HTTP或FTP服务器上，因而易于管理，基本上与防火墙无关。顺序流式传输不适合长片段和有随机访问要求的视频，如讲座、演说与演示，它也不支持现场广播。因此，严格地说来，它本质上是一种点播技术。②实时流式传输(Realtime Streaming)实时流式传输可保证媒体信号带宽与网络连接匹配，可实时观看节目。实时流与HTTP流式传输不同，它需要专用的流媒体服务器与传输协议。实时流式传输总是实时传送，因而特别适合现场事件，且支持随机访问，用户可对观看内容进行快进或后退以观看前面或后面的内容。理论上，实时流一经播放就不可停止，但实际上，可能发生周期暂停。实时流式传输必须匹配连接带宽，这意味着在以调制解调器速度连接时图像质量较差。而且，由于出错丢失的信息被忽略掉，网络拥挤或出现问题时，视频质量差，而没有顺序流式传输视频质量好。实时流式传输需要特定服务器，如QuickTime Streaming Server、RealServer与Windows Media Server。这些服务器允许你对媒体发送进行更多级别的控制，因而系统设置、管理比标准HTTP服务器更复杂。实时流式传输还需要特殊网络协议，如：RTSP(Realtime Streaming Protocol)或MMS(Microsoft Media Server)。这些协议在有防火墙时有时会出现问题，导致用户不能看到一些地点的实时内容。显然，在实际应用时，具体采用哪种传输方式可根据需要确定，且流式传输也支持在播放前完全下载到硬盘。一般情况下，流式传输模式会使用RTP/UDP、RTSP/TCP两种通信协议与A/V(Audio/Video)Server建立联系，将服务器的输出重定向到一个运行A/V Player程序所在客户机的目的地址。通常，流式传输系统一般都要配置一套专用的服务器和播放器。2.流式传输的特点与单纯的下载方式相比，这种对多媒体文件边下载边播放的流式传输方式具有以下的特点：①大幅度地缩短启动延时流式传输大幅度地缩短启动延时，因为用户不用等待所有内容下载到硬盘上才开始浏览，无论是上班时间还是晚上，速度都相当快。一般来说，一个45分钟的影片片段，在一分钟以内就显示在客户端上，而且在播放过程中，一般都不会出现断续的情况。此外，全屏播放对播放速度几乎无影响，但快进、快倒时，需要时间等待。②大大降低对系统缓存容量的需求由于Internet是以包传输为基础进行断续的异步传输，其数据被分解为许多包进行传输。动态变化的网络使各个包可能选择不同的路由，故到达用户计算机的时间延迟也就不同。因此，在客户端需要缓存系统来弥补延迟和抖动的影响和保证数据包传输顺序的正确，从而使媒体数据能连续输出，且不会因网络暂时拥堵而使播放出现停顿。虽然，流式传输仍需要缓存，但由于不需要把所有的动画、视音频内容都下载到缓存中，因而对缓存的要求大大降低。由于流媒体技术使用了数据缓冲技术，因而可保持流媒体的不间断，并保证文件传输的可靠性。③有特定的实时传输协议实现流式传输由前面叙述所知，流媒体目前有三种主流格式，并需要相应的特定的实时传输协议。一般，采用RTSP等实时传输协议，更加适合动画、视音频在网上的流式实时传输。此外，采用流媒体技术不会占用本地的硬盘空间等。 http2的持久连接和管线化 关于HTTP/1.1管道化的问答：https://jiaolonghuang.github.io/2015/08/16/http-pipelining/ 域名解析时是tcp还是udp DNS主要基于UDP运输层协议，这里解释下为什么使用UDP（User Datagram Protocol）这样的无连接的，尽最大能力交付的不可靠数据连接，而不是使用TCP(Transmission Control Protocol 传输控制协议)这样的面向连接的可靠数据连接。一次UDP名字服务器交换可以短到两个包：一个查询包、一个响应包。一次TCP交换则至少包含9个包：三次握初始化TCP会话、一个查询包、一个响应包以及四次分手的包交换。考虑到效率原因，TCP连接的开销大得，故采用UDP作为DNS的运输层协议。 域名发散和域名收敛 域名收敛–前端优化(二)：https://segmentfault.com/a/1190000004641599 域名发散–前端优化(三)：https://segmentfault.com/a/1190000004647665 HTTP Response的Header里面都有些啥？ HTTP响应头信息和请求头信息详解:http://www.cnblogs.com/mumue/archive/2012/04/23/2467072.html 浏览器相关跨域，为什么JS会对跨域做出限制 跨域那些事儿:https://zhuanlan.zhihu.com/p/28562290 前端安全：xss，csrf… xss漏洞攻击与防御:http://www.jianshu.com/p/790fb57f3acb CSRF是什么:http://www.jianshu.com/p/e825e67fcf28 浏览器怎么加载页面的？script脚本阻塞有什么解决方法？defer和async的区别？ 浏览器接收到html代码，可能是一份完整的文档，也可能是一个chunk，即开始解析。解析过程是先构建dom树，再根据dom树构建渲染树，最后浏览器将渲染树绘制到页面上。构建dom树的过程即根据html代码自上而下进行构建，当遇到script文件加载／执行会阻塞后面dom树的构建（javascript可能会改变dom树），而遇到css文件则会阻塞渲染树的构建，即dom树依然继续构建（除非遇到script标签并且css文件依旧未加载完成），但不会渲染绘制到页面上。而无论哪个阻塞，该加载的文件还是会加载，例如html文档中的其他css／js／图片文件。另外javascript被加载后就会被执行，执行的过程也阻塞树的构建。是执行完了才解析其他内容，而不是执行完了才加载其他内容。 高性能网站优化 - 无阻塞加载脚本:https://zhanglun.github.io/2014/03/30/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96-%E6%97%A0%E9%98%BB%E5%A1%9E%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC/ defer和async的区别：https://segmentfault.com/q/1010000000640869 浏览器强缓存和协商缓存 浏览器的协商缓存与强缓存:http://caibaojian.com/browser-cache.html 浏览器的全局变量有哪些&gt; 浏览器同一时间能够从一个域名下载多少资源 浏览器允许的并发请求资源数是什么意思？:https://www.zhihu.com/question/20474326 按需加载，不同页面的元素判断标准 实现按需加载JS、CSS该使用什么前端工具比较合适？:https://www.zhihu.com/question/59127551 web存储、cookies、localstroge等的使用和区别 Cookie、sessionStorage、localStorage的区别:http://www.jianshu.com/p/846c033c0cc8 浏览器的内核 各主流浏览器内核介绍:http://www.cnblogs.com/vajoy/p/3735553.html 如何实现缓存机制？（从200缓存，到cache到etag再到） http缓存控制小结:http://imweb.io/topic/5795dcb6fb312541492eda8c 说一下200和304的理解和区别 HTTP缓存技术，304和200有何区别:https://zhidao.baidu.com/question/519668331399850725.html 什么是预加载、懒加载 https://lilywei739.github.io/2017/02/06/lazyload_Img.html 一个 XMLHttpRequest 实例有多少种状态？ XMLHttpRequest().readyState的五种状态详解:http://13521308103.iteye.com/blog/1993394 浏览器渲染过程 了解HTML页面的渲染过程:http://www.cnblogs.com/yuezk/archive/2013/01/11/2855698.html 浏览器加载网页时的过程是什么？:https://www.zhihu.com/question/30218438 ie的某些兼容性问题 浏览器兼容性问题解决方案·总结:https://juejin.im/post/59a3f2fe6fb9a0249471cbb4 session 彻底弄清session是什么?:http://blog.csdn.net/think2me/article/details/38726429 拖拽实现 JavaScript实现最简单的拖拽效果:http://www.zhangxinxu.com/wordpress/2010/03/javascript%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%8B%96%E6%8B%BD%E6%95%88%E6%9E%9C/ 工程化对webpack,gulp，grunt等有没有了解?对比。 gulp与webpack的区别:http://www.cnblogs.com/lovesong/p/6413546.html Webpack、Browserify和Gulp三种之间到底是怎样的关系?:https://www.zhihu.com/question/37020798 前端构建工具 Gulp/browserify/webpack/npm?:https://www.zhihu.com/question/37694275 webpack的入口文件怎么配置，多个入口怎么分割。 入门webpack，看这篇就够了:https://segmentfault.com/a/1190000006178770 多个入口 |webpack doc:https://stephenzhao.github.io/webpack-cn/docs/multiple-entry-points.html webpack的loader和plugins的区别 webpack之loader和plugin简介:https://juejin.im/post/5980752ef265da3e2e56e82e gulp的具体使用。 前端构建工具gulp的详细使用教程:http://www.qianduan8.com/884.html gulp的使用实例:http://www.jianshu.com/p/cf15fd9dbf21 前端工程化的理解、如何自己实现一个文件打包，比如一个JS文件里同时又ES5 和ES6写的代码，如何编译兼容他们 webpack+babel使用ES6的新特性:https://rlilyyy.github.io/2016/05/04/Webpack-Babel-%E4%BD%BF%E7%94%A8-ES6-%E6%96%B0%E7%89%B9%E6%80%A7/ 模块化模块化和组件化的区别 前端开发的模块化和组件化的定义，以及两者的关系?:https://www.zhihu.com/question/37649318 对AMD,CMD,CommonJS有没有了解? Javascript模块化编程（一）：模块的写法:http://www.ruanyifeng.com/blog/2012/10/javascript_module.html Javascript模块化编程（二）：AMD规范:http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html Javascript模块化编程（三）：require.js的用法:http://www.ruanyifeng.com/blog/2012/11/require_js.html 浅析JS中的模块规范(CommonJS,AMD,CMD):http://www.cnblogs.com/skylar/p/4065455.html 为什么要模块化？不用的时候和用RequireJs的时候代码大概怎么写？ 模块化的作用有以下这些： 可以解决命名冲突管理依赖提高代码的可读性代码解耦，提高代码的复用性 使用ReruireJS来实现代码模块化:http://yanglonglong.com/blog/2016-06-11-%E4%BD%BF%E7%94%A8RequireJS%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E5%8C%96.html 说说有哪些模块化的库，有了解过模块化的发展的历史吗？ 浅谈模块化戴尔JavaScript:http://caibaojian.com/module-javascript.html 【译】从发展历史理解 ES6 Module:https://segmentfault.com/a/1190000006043377 前端模块化发展简史:https://www.ctolib.com/topics-117552.html 分别说说同步和异步模块化的应用场景，说下AMD异步模块化实现的原理？ JavaScript模块化编程(二)：AMD规范:http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html 如何将项目里面的所有的require的模块语法换成import的ES6的语法？ bebel 使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的？ JavaScript 模块化简析:http://fullstack.blog/2017/01/25/JavaScript%20%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E8%BF%B0/ 框架JS有哪些框架？zepto 和 jquery 是什么关系，有什么联系么？jquery源码如何实现选择器的，为什么$取得的对象要设计成数组的形式，这样设计的目的是什么jquery如何绑定事件，有几种类型和区别什么是MVVM，MVC，MVPVue和Angular的双向数据绑定原理Vue，Angular组件间通信以及路由原理react和vue的生命周期react和vue的虚拟dom以及diff算法vue的observer，watcher，compilereact和angular分别用在什么样的业务吗？性能方面和MVC层面上的区别jQuery对象和JS的Element有什么区别jQuery对象是怎么实现的jQuery除了它封装了一些方法外，还有什么值得我们去学习和使用的？jQuery的$(‘xxx’)做了什么事情介绍一下bootstrap的栅格系统是如何实现的Node.js对node.js有没有了解Express 和 koa 有什么关系，有什么区别？nodejs适合做什么样的业务？nodejs与php，java有什么区别Nodejs中的Stream和Buffer有什么区别？node的异步问题是如何解决的？node是如何实现高并发的？说一下 Nodejs 的 event loop 的原理数据结构基本数据结构：（数组、队列、链表、堆、二叉树、哈希表等等）8种排序算法，原理，以及适用场景和复杂度说出越多越好的斐波那契数列的实现方法？性能优化cdn的用法是什么？什么时候用到？浏览器的页面优化？如何优化 DOM 操作的性能单页面应用有什么SEO方案？单页面应用首屏显示比较慢，原因是什么？有什么解决方案？其他正则表达式前端渲染和后端渲染的优缺点数据库的四大特性，什么是原子性，表的关系你觉得前端体系应该是怎样的？一个静态资源要上线，里面有各种资源依赖，你如何平稳上线如果要你去实现一个前端模板引擎，你会怎么做知道流媒体查询吗？SEOmysql 和 mongoDB 有什么区别？restful的method解释数据库知识、操作系统知识click在ios上有300ms延迟，原因及如何解决移动端的适配，rem+媒体查询/meta头设置移动端的手势和事件；unicode，utf8，gbk编码的了解，乱码的解决三面、四面常问的开放性问题你都看过什么书？最近在看什么书？用过什么框架？有没有看过什么框架的代码？有没有学过设计模式？说一说观察者模式吧！能不能写出来？你最大的优点是什么？那你最大的缺点呢？你大学期间做过最疯狂的事情是什么？你除了写博客还有什么输出？现在你的领导给你了一份工作，要求你一个星期完成，但你看了需求以后估计需要3周才能完成，你该怎么办？平时关注的前端技术如何规划自己的职业生涯项目过程中，有遇到什么问题吗？怎么解决的？最近在研究哪方面的东西？请介绍一项你最热爱、最擅长的专业领域，并且介绍的学习规划。请介绍你参与的印象最深刻的一个项目，为什么？并且介绍你在项目中的角色和发挥的作用。HR面你为什么要学习前端？你平时的是怎么学习前端的？有什么输出？你觉得自己最好的项目是什么？身边比较佩服的人有什么值得你学习的？你为什么没有跟他们一样？同事的什么问题会让你接受不了压力最大的事情是什么？和同学做过的最好的项目？身边的朋友通常对你的评价是什么喜欢什么样的工作氛围如何看待加班有没有对象意向城市其他的offer为什么要录取你？大学里花费时间最多的三件事情周末都会干什么？未来职业规划```","categories":[],"tags":[]},{"title":"Vue学习笔记(二)","slug":"Vue学习笔记-二","date":"2017-11-04T12:57:09.000Z","updated":"2017-11-04T13:38:40.000Z","comments":true,"path":"2017/11/04/Vue学习笔记-二/","link":"","permalink":"http://akaziki.github.io/2017/11/04/Vue学习笔记-二/","excerpt":"组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is特性扩展。 组件使用定义123var MyComponent = Vue.extend(&#123; // 选项...&#125;); 注意：Vue构造器的多数选项也可以用在 Vue.extend() 中，不过有两个特例：data 和 el。如果只是将数据直接放入创建函数中，则所有组件实例都会共享同样的数据，有时候这并不是我们希望的（实际上Vue在注册组件时直接给data对象会抛出一个警告，最终会拒绝执行data解析工作），所以可以传入一个函数作为data选项——函数返回一个真正的数据对象。 注册全局注册1234Vue.component(tag, constructor);//like this:Vue.component(&quot;my-component&quot;, MyComponent); tag 表示自定义的组件名，建议使用 小写，用短杠分隔 的规则。component 是创建的组件。注册之后就可以在其它模板中使用此组件。 局部注册局部注册的目的在于:让组件只能用在其它组件内，而不是全局都可以使用。，在实例选项 components 中注册：123456789var Child = Vue.extend(&#123; /* ... */ &#125;);var Parent = Vue.extend(&#123; template: &apos;...&apos;, components: &#123; // &lt;my-component&gt; 只能用在父组件模板内 &apos;my-component&apos;: Child &#125;&#125;); 注册语法糖Vue.component() 注册函数的第二个选项可以直接传入选项对象，Vue会自动调用 Vue.extend() 函数创建组件，使用方式可简化为：12345678910111213// 在一个步骤中扩展与注册Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;)// 局部注册也可以这么做var Parent = Vue.extend(&#123; components: &#123; &apos;my-component&apos;: &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos; &#125; &#125;&#125;)","text":"组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is特性扩展。 组件使用定义123var MyComponent = Vue.extend(&#123; // 选项...&#125;); 注意：Vue构造器的多数选项也可以用在 Vue.extend() 中，不过有两个特例：data 和 el。如果只是将数据直接放入创建函数中，则所有组件实例都会共享同样的数据，有时候这并不是我们希望的（实际上Vue在注册组件时直接给data对象会抛出一个警告，最终会拒绝执行data解析工作），所以可以传入一个函数作为data选项——函数返回一个真正的数据对象。 注册全局注册1234Vue.component(tag, constructor);//like this:Vue.component(&quot;my-component&quot;, MyComponent); tag 表示自定义的组件名，建议使用 小写，用短杠分隔 的规则。component 是创建的组件。注册之后就可以在其它模板中使用此组件。 局部注册局部注册的目的在于:让组件只能用在其它组件内，而不是全局都可以使用。，在实例选项 components 中注册：123456789var Child = Vue.extend(&#123; /* ... */ &#125;);var Parent = Vue.extend(&#123; template: &apos;...&apos;, components: &#123; // &lt;my-component&gt; 只能用在父组件模板内 &apos;my-component&apos;: Child &#125;&#125;); 注册语法糖Vue.component() 注册函数的第二个选项可以直接传入选项对象，Vue会自动调用 Vue.extend() 函数创建组件，使用方式可简化为：12345678910111213// 在一个步骤中扩展与注册Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;)// 局部注册也可以这么做var Parent = Vue.extend(&#123; components: &#123; &apos;my-component&apos;: &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos; &#125; &#125;&#125;) 使用已注册的组件使用 使用自定义组件（指调用Vue构造函数初始化根实例）之前必须已经创建并且注册组件。123&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; Vue进行模板解析的时候会遵循以下html常见的限制：12345- a 不能包含其它的交互元素（如按钮，链接）- ul 和 ol 只能直接包含 li- select 只能包含 option 和 optgroup- table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup- tr 只能直接包含 th 和 td 对于自定义元素可以使用 is 特性：12345&lt;div id=&quot;example&quot;&gt;&lt;ul&gt; &lt;li is=&quot;my-component&quot;&gt;此处内容不会显示&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; 组件属性 组件实例的作用域是孤立的，props 用于将数据传给子组件。 props 是选项对象的一个字段，在组件构造时声明，在模板上用属性的方式传入：1234567Vue.component(&apos;child&apos;, &#123; // 声明 props props: [&apos;msg&apos;], // prop 可以用在模板内 // 可以用 `this.msg` 设置 template: &apos;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&apos;&#125;) 1&lt;child msg=&quot;hello!&quot;&gt;&lt;/child&gt; 注意：在 props 中用camelCase声明的字段要转换成kebab-case的方式才会生效。 动态PROPS在子组件中可以使用 v-bind 绑定动态Props到父组件的数据，当父组件的数据变化时，子组件也会跟着改变。1&lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt; PROPS绑定类型prop 默认是单向绑定的，即：父组件的属性变化将传递给子组件，但是子组件的变化不会影响父组件。Vue提供 .sync 和 .once 绑定修饰符用于显示地强制双向或单次绑定：12345678&lt;!-- 默认为单向绑定 --&gt;&lt;child :msg=&quot;parentMsg&quot;&gt;&lt;/child&gt;&lt;!-- 双向绑定 --&gt;&lt;child :msg.sync=&quot;parentMsg&quot;&gt;&lt;/child&gt;&lt;!-- 单次绑定 --&gt;&lt;child :msg.once=&quot;parentMsg&quot;&gt;&lt;/child&gt; 注意：如果prop是一个对象或者数组，Vue是按引用传递数据的，所以无论是否指明双向绑定，实际上都是“双向绑定”的。 PROPS验证指定prop验证的意义在于：约束使用组件的其它人，带验证时 props 字段应该是一个对象：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Vue.component(&apos;example&apos;, &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 (1.0.21+) propM: [String, Number], // 必需且是字符串 propB: &#123; type: String, required: true &#125;, // 数字，有默认值 propC: &#123; type: Number, default: 100 &#125;, // 对象/数组的默认值应当由一个函数返回 propD: &#123; type: Object, default: function () &#123; return &#123; msg: &apos;hello&apos; &#125; &#125; &#125;, // 指定这个 prop 为双向绑定 // 如果绑定类型不对将抛出一条警告 propE: &#123; twoWay: true &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125;, // 转换函数（1.0.12 新增） // 在设置值之前转换值 propG: &#123; coerce: function (val) &#123; return val + &apos;&apos; // 将值转换为字符串 &#125; &#125;, propH: &#123; coerce: function (val) &#123; return JSON.parse(val) // 将 JSON 字符串转换为对象 &#125; &#125; &#125;&#125;); type 可以是下面的原生构造器之一： String Number Boolean Function Obiect Array 也可以是自定义的构造器：使用 instanceof 检测。 组件通信父链父链指的是因组件之间的嵌套关系产生的关系链，Vue定义了三个关于父链的变量： this.$parent:指向父组件的实例； this.$root:指向根对象； this.$children:父组件的一个数组，包含它所有的子元素； 自定义事件Vue的自定义事件接口一共提供四个方法: $on():监听事件； $emit():在组件实例上触发事件； $dispatch():派发事件，沿着父链冒泡； $brjoadcast():广播事件，事件向下传导分为所有后代； 使用方式:1234567891011&lt;!-- 子组件模板 --&gt;&lt;template id=&quot;child-template&quot;&gt; &lt;input v-model=&quot;msg&quot;&gt; &lt;button v-on:click=&quot;notify&quot;&gt;Dispatch Event&lt;/button&gt;&lt;/template&gt;&lt;!-- 父组件模板 --&gt;&lt;div id=&quot;events-example&quot;&gt; &lt;p&gt;Messages: &#123;&#123; messages | json &#125;&#125;&lt;/p&gt; &lt;child v-on:child-msg=&quot;handleIt&quot;&gt;&lt;/child&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132// 注册子组件// 将当前消息派发出去Vue.component(&apos;child&apos;, &#123; template: &apos;#child-template&apos;, data: function () &#123; return &#123; msg: &apos;hello&apos; &#125; &#125;, methods: &#123; notify: function () &#123; if (this.msg.trim()) &#123; this.$emit(&apos;child-msg&apos;, this.msg) this.msg = &apos;&apos; &#125; &#125; &#125;&#125;)// 初始化父组件// 将收到消息时将事件推入一个数组var parent = new Vue(&#123; el: &apos;#events-example&apos;, data: &#123; messages: [] &#125;, // 在创建实例时 `events` 选项简单地调用 `$on` methods: &#123; &apos;handleIt&apos;: function (msg) &#123; // 事件回调内的 `this` 自动绑定到注册它的实例上 this.messages.push(msg) &#125; &#125;&#125;) 注意： 不同于DOM事件，Vue事件在冒泡过程中第一次触发回调之后自动停止冒泡，除非回调明确返回true； Vue的事件时同步机制，执行dispatch后会等待一个返回再接着执行； 子组件索引Vue中可以使用v-ref为子组件指定一个索引ID，用于直接访问子组件。Vue实例的$refs包含父组件中所有制定了v-ref属相的子组件，当执行v-ref和v-for一起使用时$refs是一个数组，否则是一个对象。 组件内容分发Vue使用slot特性进行内容分发 在父组件放入已被slot标记的内容，这些内容的顺序可以随意。之后这些内容被分发到子组件的特殊元素slot中，根据name属性在子组件中重新组合。 需要注意的是，内容应该被放在父组件模板的子组件中：123456789&lt;!--父组件模板--&gt;&lt;div id=&quot;parent-template&quot;&gt; &lt;child&gt; &lt;!--此处是待分发的内容--&gt; &lt;p slot=&quot;one&quot;&gt;one&lt;/p&gt; &lt;p slot=&quot;two&quot;&gt;two&lt;/p&gt; &lt;p&gt;default&lt;/p&gt; &lt;/child&gt;&lt;/div&gt; 父组件模板中的内容被分发到子组件中重新组合，请看子组件的模板：1234567&lt;!--子组件的模板--&gt;&lt;div&gt; &lt;h1&gt;内容被分发且重新组合&lt;/h1&gt; &lt;slot&gt;默认分发处&lt;/slot&gt; &lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;&lt;/div&gt; 初始化父组件实例之前要祖册子组件：1234567891011121314// 注册子组件Vue.component(&quot;child&quot;, &#123; template: &apos;&lt;div&gt;&apos;+ &apos;&lt;h1&gt;内容被分发且重新组合&lt;/h1&gt;&apos;+ &apos;&lt;slot&gt;默认分发处&lt;/slot&gt;&apos;+ &apos;&lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt;&apos;+ &apos;&lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;&apos;+&apos;&lt;/div&gt;&apos;&#125;);// 初始化父组件new Vue(&#123; el: &quot;#parent-template&quot;&#125;); 异步组件Vue允许讲组件定义为一个工厂函数，在组件需要渲染是触发工厂函数动态地解析组件，并且将结果缓存起来：12345678Vue.component(&quot;async-component&quot;, function(resolve, reject)&#123; // async operation setTimeout(function() &#123; resolve(&#123; template: &apos;&lt;div&gt;something async&lt;/div&gt;&apos; &#125;); &#125;,1000);&#125;); 配合WEBPACK实现代码分割webpack可以讲代码分割成块，在需要次块时再使用ajax的方式下载：123456Vue.component(&apos;async-webpack-example&apos;, function(resolve) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 ajax 请求自动下载。 require([&apos;./my-async-component&apos;], resolve)&#125;);","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://akaziki.github.io/tags/学习笔记/"},{"name":"Vue","slug":"Vue","permalink":"http://akaziki.github.io/tags/Vue/"}]},{"title":"Flex布局笔记","slug":"Flex布局笔记","date":"2017-11-02T03:37:41.000Z","updated":"2017-11-02T13:55:02.000Z","comments":true,"path":"2017/11/02/Flex布局笔记/","link":"","permalink":"http://akaziki.github.io/2017/11/02/Flex布局笔记/","excerpt":"Flex 布局是什么Flex是Flexible Box的缩写，意思为“弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。123.box&#123; display : inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。1234.box&#123; display ：-webkit-flex; /*Safari*/ display : flex;&#125; 注意，设为Flex布局以后，子元素的float、clear、和vertical-align属性将失效。 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。","text":"Flex 布局是什么Flex是Flexible Box的缩写，意思为“弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。123.box&#123; display : inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。1234.box&#123; display ：-webkit-flex; /*Safari*/ display : flex;&#125; 注意，设为Flex布局以后，子元素的float、clear、和vertical-align属性将失效。 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上: flex-direction:决定主轴的方向（即项目的排列方向）row(默认值):主轴为水平方向，起点在左端row-reverse:主轴为水平方向，起点在右端column:主轴为垂直方向，起点在上沿column-reverse:主轴为垂直方向，起点在下沿 flex-wrap:定义如果一条轴线排不下，如何换行nowrap(默认值):不换行wrap:换行，第一行在上方wrap-reverse:换行，第一行在下方 flex-flow:flex-direction属性和flex-wrap属性的简写形式&lt;flex-direction&gt; || &lt;flex-wrap&gt; justify-content:定义项目在主轴上的对齐方式flex-start(默认值):左对齐flex-end:右对齐center:居中space-between:两端对齐，项目之间的间隔都相等space-around:每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 align-items:定义练手在交叉轴上如何对齐flex-start:交叉轴的起点对齐flex-end:交叉轴的重点对齐center:交叉轴的中点对齐baseline:项目的第一行文字的基线对齐stretch(默认值):如果项目未设置高度或设为auto，将占满整个容器的高度 align-content:定义了多跟轴线的对齐方式flex-start:与交叉轴的起点对齐flex-end:与交叉轴的终点对齐center:与交叉轴的中点对齐space-between:与交叉轴两端对齐，轴线之间的间隔平均分布space-around:每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍stretch(默认值):轴线占满整个交叉轴 项目的属性以下6个属性设置在项目上: order:定义项目排列顺序&lt;integer&gt;:数值越小，排列越靠前，默认为0。 flex-grow:定义项目的放大比例&lt;number&gt;:默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们等分剩余空间。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 flex-shrink:定义了项目的缩小比例&lt;number&gt;:默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，档空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 flex-basis:定义了在分配多余空间之前，项目占据的主轴空间(mian size)&lt;length&gt; : | auto:浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值(比如350px)，则项目将占据固定空间 flex:是flex-grow，flex-shrink和flex-basic的简写none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]:默认值为0 1 auto(后两个属性可选)。 align-self:属性允许单个项目有与其他项目不一样的对齐方式auto | flex-start | flex-end | center | baseline | stretch除了auto，其他都与align-items属性完全一致。可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 参考文章：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://akaziki.github.io/tags/CSS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://akaziki.github.io/tags/学习笔记/"}]},{"title":"Vue学习笔记(一)","slug":"Vue学习笔记-一","date":"2017-10-30T12:51:15.000Z","updated":"2017-10-31T01:07:42.000Z","comments":true,"path":"2017/10/30/Vue学习笔记-一/","link":"","permalink":"http://akaziki.github.io/2017/10/30/Vue学习笔记-一/","excerpt":"VueJs： 数据驱动的组件，为现代化的 Web 界面而生 Vue的核心包括两部分： 响应的数据绑定：数据驱动视图，操作数据而非DOM，通过指令实现功能扩展； 组件系统：vue应用可以看成是一棵组件树，vue提供组件间的数据流，自定义事件系统，带特效的组件替换效果等； Vue官网中专门有一篇文章讲Vue和其它框架的对比，个人觉得有点参考价值，从中可以窥见很多Vue重要的特性： 对比 angular Vue专注视图层，更轻，性能占优； Vue只允许父组件单向地传递数据给子组件； Vue不执行脏检查，使用基于依赖追踪的观察系统，且使用异步队列更新； 对比 react Vue建立在真实DOM结构上； 轻量级的 DSL (指令系统)，直观简洁的模板； Vue也有自己的状态管理方案：Vuex； 其它特点 与webpack无缝整合； 支持ES6和CSS预处理器； 另外在组件封装方面，下面一张图就可以很好地展现Vue的特性","text":"VueJs： 数据驱动的组件，为现代化的 Web 界面而生 Vue的核心包括两部分： 响应的数据绑定：数据驱动视图，操作数据而非DOM，通过指令实现功能扩展； 组件系统：vue应用可以看成是一棵组件树，vue提供组件间的数据流，自定义事件系统，带特效的组件替换效果等； Vue官网中专门有一篇文章讲Vue和其它框架的对比，个人觉得有点参考价值，从中可以窥见很多Vue重要的特性： 对比 angular Vue专注视图层，更轻，性能占优； Vue只允许父组件单向地传递数据给子组件； Vue不执行脏检查，使用基于依赖追踪的观察系统，且使用异步队列更新； 对比 react Vue建立在真实DOM结构上； 轻量级的 DSL (指令系统)，直观简洁的模板； Vue也有自己的状态管理方案：Vuex； 其它特点 与webpack无缝整合； 支持ES6和CSS预处理器； 另外在组件封装方面，下面一张图就可以很好地展现Vue的特性 demo效果 JS代码在实现这个demo时，Vue的语法显得相当简洁，整个应用的核心逻辑都包裹在一个传输给 Vue 构造函数作为形参的对象中，demo中主要包括：el，data，methods三部分： 1234567891011121314151617181920new Vue(&#123; el: &quot;#app&quot;, // 指定应用的根元素 data: &#123; // 数据 newtodo: &apos;&apos;, todos: [] &#125;, methods: &#123; // 方法 addTodo: function() &#123; if (this.newtodo) &#123; this.todos.push(&#123; text: this.newtodo &#125;); &#125; this.newtodo = &apos;&apos;; &#125;, rmTodo: function(index) &#123; this.todos.splice(index, 1); &#125; &#125;&#125;); HTML结构Vue的 HTML 结构和 angular 有类似的地方：两者都是用 HTML 的方式来扩充 HTML 功能，包括双向数据绑定，循环，事件绑定等 12345678910&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;newtodo&quot;&gt; &lt;button v-on:click=&quot;addTodo&quot;&gt;add&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123;todo.text&#125;&#125; &lt;button v-on:click=&quot;rmTodo($index)&quot;&gt;&amp;Chi;&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 构造函数构件vue应用的第一步是调用Vue构造函数，传入的选项对象包括：数据，模板，挂载元素，方法，生命周期钩子等。 data：每个Vue实例都会代理 data 对象中所有的属性，“代理”属性其实就是建立引用，一方改变，另一方也会变化； 以$开头的属性和方法： 12345678910111213var data = &#123; a: 1 &#125;;var vm = new Vue(&#123; el: &apos;#example&apos;, data: data&#125;);vm.$data === data // -&gt; truevm.$el === document.getElementById(&apos;example&apos;) // -&gt; true// $watch 是一个实例方法vm.$watch(&apos;a&apos;, function (newVal, oldVal) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 生命周期钩子：created，compiled，ready，destroyed等，生命周期的示意图: 数据绑定语法插值 文本Vue的文本插值采用“mustache”双大括号语法，双大括号中的msg表示data中的msg属性字段,like this： 1&lt;span&gt;msg: &#123;&#123;msg&#125;&#125;&lt;/span&gt; HTML要插入原始的HTML需要使用三大括号语法： 1&#123;&#123;&#123; thisis_html &#125;&#125;&#125; 将内容直接以html的方式插入存在风险，建议只对信任的内容做此操作。 HTML特性mustache标签也可用在HTML特性内：1&lt;div class=&quot;item-&#123;&#123;class&#125;&#125;&quot;&gt; 绑定表达式 放在mustache标签内的文本被称为绑定表达式，此表达式内可以由一个简单的JavaScript表达式和可选的过滤器组成。 表达式：单个的表达式内不能有语句和流程控制语句，除此之外支持全功能的JavaScript表达式： 12345&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 过滤器：Vue会以“pipeline”的方式将数据传递给过滤器，语法用 | 表示，同时过滤器也支持传参： 1&#123;&#123; msg | filterA filterA_arg | filterB &#125;&#125; 指令在Vue中，指令以前缀 v- 开头，其职责是：当其表达式的值改变时把某些特殊的行为应用到DOM上。指令的值称为绑定表达式。 指令的参数用冒号 : 隔开，比如 v-bind 指令用于响应的更新html特性，具体的attribute以冒号后参数的形式传递： 1&lt;a v-bind:href = &quot;url&quot;&gt;&lt;/a&gt; 缩写vue提供特定指令的缩写形式： v-bind：缩写形式中可以直接去掉v-bind：1&lt;a :href = &quot;url&quot;&gt;&lt;/a&gt;; v-on：用 @ 表示：1&lt;a @click = &quot;dosomething&quot;&gt;; 计算属性计算属性是一个function，在function中返回一个值，这个值可能会依赖于其它数据，定义在 computed 属性下：123456789101112var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125;, computed: &#123; fullName: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125;&#125;) Class与Style绑定 Vue对Class与Style绑定做了专门优化，支持对象与数组语法。 Class 对象语法 1&lt;div v-bind:class=&quot;&#123;&apos;class-a&apos;: isA, &apos;class-b&apos;: isB&apos;&#125;&quot;&gt;&lt;/div&gt; 数组语法 1&lt;div v-bind:class=&quot;[classA, classB]&quot;&gt; 数组语法与对象语法不同之处在于：对象语法中data里存的是属性值命名的字段，而数组中则直接是数组元素命名的字段。 Stylestyle绑定语法与class类似，不再赘述，如12&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;div v-bind:style=&quot;[styleObjectA, styleObjectB]&quot;&gt; 条件渲染 v-if：根据 v-if 绑定的值来控制是否渲染DOM，其可以配合 &lt;template&gt;&lt;/template&gt; 实现多个元素的渲染控制，此外还可搭配 v-show 语法： 12345&lt;template v-if=&quot;isShow&quot;&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;p&gt;this is content.&lt;/p&gt;&lt;/template&gt;&lt;p v-else&gt;sorry.&lt;/p&gt; v-show：根据绑定值控制DOM元素是否显示。使用方法与 v-if 类似。但不可使用 &lt;template&gt; 和 v-show。 两者的区别在于 v-if 是真实的条件渲染，而 v-show 只是控制 display 属性来展示/隐藏元素，DOM元素始终存在，具体使用哪个应该根据场景切换频率来定。 列表渲染列表渲染使用 v-for ，使用方法如下： 12345&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;) 方法与事件处理基本的使用方法：1&lt;button v-on:click=&quot;say(&apos;hello!&apos;, $event)&quot;&gt;Submit&lt;/button&gt; 123456methods: &#123; say: function (msg, event) &#123; // 现在我们可以访问原生事件对象 event.preventDefault() &#125;&#125; ##事件修饰符 Vue为 event.preventDefault() 和 event.stopPropagation() 提供了两个修饰符：.prevent 和 .stop：1234567891011&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt; 1.0.16 添加了两个额外的修饰符：12345&lt;!-- 添加事件侦听器时使用 capture 模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 表单控件绑定 使用 v-model 指令在表单元素上创建双向数据绑定。 常见表单元素的绑定方式如下：1234567891011121314151617181920212223242526272829303132333435363738&lt;!--text--&gt;&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;!--textarea--&gt;&lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;&lt;!--checkbox--&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;!--radio：不需要通过name来绑定一组radio--&gt;&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;&lt;br&gt;&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;&lt;!--select：option有value选项时取value值，否则去innerText值--&gt;&lt;select v-model=&quot;selected&quot;&gt; &lt;option selected&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;!--v-model配合v-bind使用以绑定value到动态属性上--&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;pick&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt;&lt;span&gt;Selected: &#123;&#123; pick &#125;&#125;&lt;/span&gt;&lt;!--使用lazy参数将事件从input变为change--&gt;&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model=&quot;msg&quot; lazy&gt;&lt;!--将用户的输入转为 Number 类型（如果原值的转换结果为 NaN 则返回原值） --&gt;&lt;input v-model=&quot;age&quot; number&gt;&lt;!--debounce 设置一个最小的延时，在每次敲击之后延时同步输入框的值与数据。--&gt;&lt;!--注意 debounce 参数不会延迟 input 事件：它延迟“写入”底层数据。--&gt;&lt;input v-model=&quot;msg&quot; debounce=&quot;500&quot;&gt;","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://akaziki.github.io/tags/学习笔记/"},{"name":"Vue","slug":"Vue","permalink":"http://akaziki.github.io/tags/Vue/"}]},{"title":"CSS样式大全","slug":"CSS样式大全","date":"2017-10-30T12:22:42.000Z","updated":"2017-11-02T12:41:38.000Z","comments":true,"path":"2017/10/30/CSS样式大全/","link":"","permalink":"http://akaziki.github.io/2017/10/30/CSS样式大全/","excerpt":"","text":"本文可以作为一个平时使用的css参考手册，文章来源于网上，具体见文章末尾。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284字体属性：(font)大小 &#123;font-size: x-large;&#125;(特大) xx-small;(极小) 一般中文用不到，只要用数值就可以，单位：PX、PD样式 &#123;font-style: oblique;&#125;(偏斜体) italic;(斜体) normal;(正常)行高 &#123;line-height: normal;&#125;(正常) 单位：PX、PD、EM粗细 &#123;font-weight: bold;&#125;(粗体) lighter;(细体) normal;(正常)变体 &#123;font-variant: small-caps;&#125;(小型大写字母) normal;(正常)大小写 &#123;text-transform: capitalize;&#125;(首字母大写) uppercase;(大写) lowercase;(小写) none;(无)修饰 &#123;text-decoration: underline;&#125;(下划线) overline;(上划线) line-through;(删除线) blink;(闪烁)常用字体： (font-family)&quot;Courier New&quot;, Courier, monospace, &quot;Times New Roman&quot;,Times, serif, Arial, Helvetica, sans-serif, Verdana背景属性： (background)色彩 &#123;background-color: #FFFFFF;&#125;图片 &#123;background-image: url();&#125;重复 &#123;background-repeat: no-repeat;&#125;滚动 &#123;background-attachment: fixed;&#125;(固定) scroll;(滚动)位置 &#123;background-position: left;&#125;(水平) top(垂直);简写方法 &#123;background:#000 url(..) repeat fixed left top;&#125;/*简写·这个在阅读代码中经常出现，要认真的研究*/区块属性： (Block) /*这个属性第一次认识，要多多研究*/字间距 &#123;letter-spacing: normal;&#125; 数值 /*这个属性似乎有用，多实践下*/对齐 &#123;text-align: justify;&#125;(两端对齐) left;(左对齐) rightright;(右对齐) center;(居中)缩进 &#123;text-indent: 数值px;&#125;垂直对齐 &#123;vertical-align: baselinebaseline;&#125;(基线) sub;(下标) super;(下标) top; text-top; middle; bottombottom; text-bottom;词间距word-spacing: normal; 数值空格whitewhite-space: pre;(保留) nowrap;(不换行)显示 &#123;display:block;&#125;(块) inline;(内嵌) list-item;(列表项) run-in;(追加部分) compact;(紧凑)marker;(标记)table; inline-table; table-raw-group; table-header-group;table-footer-group;table-raw; table-column-group; table-column;table-cell; table-caption;(表格标题) /*display 属性的了解很模糊*/方框属性： (Box)width:; height:; float:; clear:both; margin:; padding:; 顺序：上右下左边框属性： (Border)border-style: dotted;(点线) dashed;(虚线) solid; double;(双线)groove;(槽线) ridge;(脊状) inset;(凹陷) outset;border-width:; 边框宽度border-color:#;简写方法border：width style color; /*简写*/列表属性： (List-style)类型list-style-type: disc;(圆点) circle;(圆圈) square;(方块) decimal;(数字)lower-roman;(小罗码数字) upper-roman; lower-alpha; upper-alpha;位置list-style-position: outside;(外) inside;图像list-style-image: url(..);定位属性： (Position)Position: absolute; relative; static;visibility: inherit; visible; hidden;overflow: visible; hidden; scroll; auto;clip: rect(12px,auto,12px,auto) (裁切)css属性代码大全一 CSS文字属性：color : #999999; /*文字颜色*/font-family : 宋体,sans-serif; /*文字字体*/font-size : 9pt; /*文字大小*/font-style:itelic; /*文字斜体*/font-variant:small-caps; /*小字体*/letter-spacing : 1pt; /*字间距离*/line-height : 200%; /*设置行高*/font-weight:bold; /*文字粗体*/vertical-align:sub; /*下标字*/vertical-align:super; /*上标字*/text-decoration:line-through; /*加删除线*/text-decoration: overline; /*加顶线*/text-decoration:underline; /*加下划线*/text-decoration:none; /*删除链接下划线*/text-transform : capitalize; /*首字大写*/text-transform : uppercase; /*英文大写*/text-transform : lowercase; /*英文小写*/text-align:rightright; /*文字右对齐*/text-align:left; /*文字左对齐*/text-align:center; /*文字居中对齐*/text-align:justify; /*文字分散对齐*/vertical-align属性vertical-align:top; /*垂直向上对齐*/vertical-align:bottombottom; /*垂直向下对齐*/vertical-align:middle; /*垂直居中对齐*/vertical-align:text-top; /*文字垂直向上对齐*/vertical-align:text-bottom; /*文字垂直向下对齐*/二、CSS边框空白padding-top:10px; /*上边框留空白*/padding-right:10px; /*右边框留空白*/padding-bottom:10px; /*下边框留空白*/padding-left:10px; /*左边框留空白三、CSS符号属性：list-style-type:none; /*不编号*/list-style-type:decimal; /*阿拉伯数字*/list-style-type:lower-roman; /*小写罗马数字*/list-style-type:upper-roman; /*大写罗马数字*/list-style-type:lower-alpha; /*小写英文字母*/list-style-type:upper-alpha; /*大写英文字母*/list-style-type:disc; /*实心圆形符号*/list-style-type:circle; /*空心圆形符号*/list-style-type:square; /*实心方形符号*/list-style-image:url(/dot.gif); /*图片式符号*/list-style-position: outside; /*凸排*/list-style-position:inside; /*缩进*/四、CSS背景样式：background-color:#F5E2EC; /*背景颜色*/background:transparent; /*透视背景*/background-image : url(/image/bg.gif); /*背景图片*/background-attachment : fixed; /*浮水印固定背景*/background-repeat : repeat; /*重复排列-网页默认*/background-repeat : no-repeat; /*不重复排列*/background-repeat : repeat-x; /*在x轴重复排列*/background-repeat : repeat-y; /*在y轴重复排列*/指定背景位置background-position : 90% 90%; /*背景图片x与y轴的位置*/background-position : top; /*向上对齐*/background-position : buttom; /*向下对齐*/background-position : left; /*向左对齐*/background-position : rightright; /*向右对齐*/background-position : center; /*居中对齐*/五、CSS连接属性：a /*所有超链接*/a:link /*超链接文字格式*/a:visited /*浏览过的链接文字格式*/a:active /*按下链接的格式*/a:hover /*鼠标转到链接*/鼠标光标样式：链接手指 CURSOR: hand十字体 cursor:crosshair箭头朝下 cursor:s-resize十字箭头 cursor:move箭头朝右 cursor:move加一问号 cursor:help箭头朝左 cursor:w-resize箭头朝上 cursor:n-resize箭头朝右上 cursor:ne-resize箭头朝左上 cursor:nw-resize文字I型 cursor:text箭头斜右下 cursor:se-resize箭头斜左下 cursor:sw-resize漏斗 cursor:wait光标图案(IE6) p &#123;cursor:url(&quot;光标文件名.cur&quot;),text;&#125;六、CSS框线一览表：border-top : 1px solid #6699cc; /*上框线*/border-bottom : 1px solid #6699cc; /*下框线*/border-left : 1px solid #6699cc; /*左框线*/border-right : 1px solid #6699cc; /*右框线*/以上是建议书写方式,但也可以使用常规的方式 如下:border-top-color : #369 /*设置上框线top颜色*/border-top-width :1px /*设置上框线top宽度*/border-top-style : solid/*设置上框线top样式*/其他框线样式solid /*实线框*/dotted /*虚线框*/double /*双线框*/groove /*立体内凸框*/ridge /*立体浮雕框*/inset /*凹框*/outset /*凸框*/七、CSS表单运用：文字方块按钮复选框选择钮多行文字方块下拉式菜单 选项1选项2八、CSS边界样式：margin-top:10px; /*上边界*/margin-right:10px; /*右边界值*/margin-bottom:10px; /*下边界值*/margin-left:10px; /*左边界值*/CSS 属性： 字体样式(Font Style)序号 中文说明 标记语法1 字体样式 &#123;font:font-style font-variant font-weight font-size font-family&#125;2 字体类型 &#123;font-family:&quot;字体1&quot;,&quot;字体2&quot;,&quot;字体3&quot;,...&#125;3 字体大小 &#123;font-size:数值|inherit| medium| large| larger| x-large| xx-large| small| smaller| x-small| xx-small&#125;4 字体风格 &#123;font-style:inherit|italic|normal|oblique&#125;5 字体粗细 &#123;font-weight:100-900|bold|bolder|lighter|normal;&#125;6 字体颜色 &#123;color:数值;&#125;7 阴影颜色 &#123;text-shadow:16位色值&#125;8 字体行高 &#123;line-height:数值|inherit|normal;&#125;9 字 间 距 &#123;letter-spacing:数值|inherit|normal&#125;10 单词间距 &#123;word-spacing:数值|inherit|normal&#125;11 字体变形 &#123;font-variant:inherit|normal|small-cps &#125;12 英文转换 &#123;text-transform:inherit|none|capitalize|uppercase|lowercase&#125;13 字体变形 &#123;font-size-adjust:inherit|none&#125;14 字体 &#123;font-stretch:condensed|expanded|extra-condensed|extra-expanded|inherit|narrower|normal| semi-condensed|semi-expanded|ultra-condensed|ultra-expanded|wider&#125;文本样式(Text Style)序号 中文说明 标记语法1 行 间 距 &#123;line-height:数值|inherit|normal;&#125;2 文本修饰 &#123;text-decoration:inherit|none|underline|overline|line-through|blink&#125;3 段首空格 &#123;text-indent:数值|inherit&#125;4 水平对齐 &#123;text-align:left|rightright|center|justify&#125;5 垂直对齐 &#123;vertical-align:inherit|top|bottombottom|text-top|text-bottom|baselinebaseline|middle|sub|super&#125;6 书写方式 &#123;writing-mode:lr-tb|tb-rl&#125;背景样式序号 中文说明 标记语法1 背景颜色 &#123;background-color:数值&#125;2 背景图片 &#123;background-image: url(URL)|none&#125;3 背景重复 &#123;background-repeat:inherit|no-repeat|repeat|repeat-x|repeat-y&#125;4 背景固定 &#123;background-attachment:fixed|scroll&#125;5 背景定位 &#123;background-position:数值|top|bottombottom|left|rightright|center&#125;6 背影样式 &#123;background:背景颜色|背景图象|背景重复|背景附件|背景位置&#125;框架样式(Box Style)序号 中文说明 标记语法1 边界留白 &#123;margin:margin-top margin-right margin-bottom margin-left&#125;2 补 白 &#123;padding:padding-top padding-right padding-bottom padding-left&#125;3 边框宽度 &#123;border-width:border-top-width border-right-width border-bottom-width border-left-width&#125;宽度值： thin|medium|thick|数值4 边框颜色 &#123;border-color:数值 数值 数值 数值&#125; 数值：分别代表top、rightright、bottombottom、left颜色值5 边框风格 &#123;border-style:none|hidden|inherit|dashed|solid|double|inset|outset|ridge|groove&#125;6 边 框 &#123;border:border-width border-style color&#125;上 边 框 &#123;border-top:border-top-width border-style color&#125;右 边 框 &#123;border-right:border-right-width border-style color&#125;下 边 框 &#123;border-bottom:border-bottom-width border-style color&#125;左 边 框 &#123;border-left:border-left-width border-style color&#125;7 宽 度 &#123;width:长度|百分比| auto&#125;8 高 度 &#123;height:数值|auto&#125;9 漂 浮 &#123;float:left|rightright|none&#125;10 清 除 &#123;clear:none|left|rightright|both&#125;分类列表序号 中文说明 标记语法1 控制显示 &#123;display:none|block|inline|list-item&#125;2 控制空白 &#123;whitewhite-space:normal|pre|nowarp&#125;3 符号列表 &#123;list-style-type:disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none&#125;4 图形列表 &#123;list-style-image:URL&#125;5 位置列表 &#123;list-style-position:inside|outside&#125;6 目录列表 &#123;list-style:目录样式类型|目录样式位置|url&#125;7 鼠标形状 &#123;cursor:hand|crosshair|text|wait|move|help|e-resize|nw-resize|w-resize|s-resize|se-resize|sw-resize&#125; 文章来源：https://150643.com/442.html","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://akaziki.github.io/tags/CSS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://akaziki.github.io/tags/学习笔记/"}]},{"title":"关于JSON","slug":"关于JSON","date":"2017-10-13T04:54:23.000Z","updated":"2017-11-02T12:42:32.000Z","comments":true,"path":"2017/10/13/关于JSON/","link":"","permalink":"http://akaziki.github.io/2017/10/13/关于JSON/","excerpt":"&emsp;&emsp;之前一直误以为JavaScript中的对象字面量（Object Literals）就是JSON对象，因为它的语法和JSON规范里描述的一样,但是该规范也明确地说了JSON只是一个数据交换语言，只有我们将其用在string上下文的时候它才叫JSON。 序列化与反序列化&emsp;&emsp;两个程序（或服务器、语言等）需要交互通信的时候，他们倾向于使用string字符串因为string在很多语言里解析的方式都差不多。复杂的数据结构经常需要用到，并且通过各种各样的中括号{}，小括号()，方括号[]和空格来组成，这个字符串仅仅是按照要求规范好的字符。 &emsp;&emsp;为此，我们为了描述这些复杂的数据结构作为一个string字符串，制定了标准的规则和语法。JSON只是其中一种语法，它可以在string上下文里描述对象，数组，字符串，数字，布尔型和null，然后通过程序间传输，并且反序列化成所需要的格式。YAML和XML也是流行的数据交换格式，但是作为前端开发人员都喜欢JSON。 字面量 它们是固定的值，不是变量，让你从”字面上”了解脚本。 字符串字面量是有双引号（”）或单引号（’）包围起来的零个或多个字符组成的。 对象字面量是由大括号（{}）括起来的零个或多个对象的属性名-值对。","text":"&emsp;&emsp;之前一直误以为JavaScript中的对象字面量（Object Literals）就是JSON对象，因为它的语法和JSON规范里描述的一样,但是该规范也明确地说了JSON只是一个数据交换语言，只有我们将其用在string上下文的时候它才叫JSON。 序列化与反序列化&emsp;&emsp;两个程序（或服务器、语言等）需要交互通信的时候，他们倾向于使用string字符串因为string在很多语言里解析的方式都差不多。复杂的数据结构经常需要用到，并且通过各种各样的中括号{}，小括号()，方括号[]和空格来组成，这个字符串仅仅是按照要求规范好的字符。 &emsp;&emsp;为此，我们为了描述这些复杂的数据结构作为一个string字符串，制定了标准的规则和语法。JSON只是其中一种语法，它可以在string上下文里描述对象，数组，字符串，数字，布尔型和null，然后通过程序间传输，并且反序列化成所需要的格式。YAML和XML也是流行的数据交换格式，但是作为前端开发人员都喜欢JSON。 字面量 它们是固定的值，不是变量，让你从”字面上”了解脚本。 字符串字面量是有双引号（”）或单引号（’）包围起来的零个或多个字符组成的。 对象字面量是由大括号（{}）括起来的零个或多个对象的属性名-值对。 何时是JSON，何时不是JSON？&emsp;&emsp;JSON是设计成描述数据焦金环格式的，它也有自己的语法这个语法是JavaScript的一个子集。{ “prop”: “val” } 这样的声明有可能是JavaScript对象字面量也有可能是JSON字符串，取决于什么上下文使用它，如果是用在string上下文（用单引号或双引号引住，或者从text文件读取）的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。 12345//这是JSON字符串var foo = &apos;&#123;&quot;prop&quot; : &quot;val&quot;&#125;&apos;;//这是对象字面量var bar = &#123;&quot;prop&quot; : &quot;val&quot;&#125;; &emsp;&emsp;而且要注意，JSON有非常严格的语法，在string上下文里{“prop” : “val”}是个合法的JSON，但是{prop : “val”}确实不合法。所有属性名称和它的值都必须用双引号引住，不能使用单引号。另外，即便你使用了了转义以后的单引号也是不合法的，详细的一发规则可以这里查看。 真正的JSON对象&emsp;&emsp;开头已经提到，对象字面量不是JSON对象，但是有真正的JSON对象。但是两者完全不一样概念，在新版的浏览器里JSON对象已经被原生的内置对象了，目前有2个静态方法：JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。老版本的浏览器不支持这个对象，但可以通过json2.js来实现同样的功能。 可以参考下边的例子： 12345678910// 这是JSON字符串，比如从AJAX获取字符串信息var my_json_string = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;; // 将字符串反序列化成对象var my_obj = JSON.parse( my_json_string ); alert( my_obj.prop == &apos;val&apos; ); // 提示 true, 和想象的一样! // 将对象序列化成JSON字符串var my_other_json_string = JSON.stringify( my_obj ); 参考文章：http://www.cnblogs.com/zichi/p/4360219.html","categories":[],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://akaziki.github.io/tags/JSON/"}]},{"title":"如何在博客中插入jsfiddle代码","slug":"如何在博客中插入jsfiddle代码","date":"2017-10-11T06:21:27.000Z","updated":"2017-11-06T02:17:22.000Z","comments":true,"path":"2017/10/11/如何在博客中插入jsfiddle代码/","link":"","permalink":"http://akaziki.github.io/2017/10/11/如何在博客中插入jsfiddle代码/","excerpt":"&emsp;&emsp;之前看到有些博文里可以把HTML、CSS、JavaScript代码和运行结果直接显示在一个iframe中，就觉得这个方式挺有用的。首先是不占据多少文章地方，主要是比较清晰，代码和结果一目了然。今天特地去找了一下是利用什么来实现的。网上搜了一会，大概明白了如何实现，下面是预览效果(请耐心等待一下，可能加载有点慢)：","text":"&emsp;&emsp;之前看到有些博文里可以把HTML、CSS、JavaScript代码和运行结果直接显示在一个iframe中，就觉得这个方式挺有用的。首先是不占据多少文章地方，主要是比较清晰，代码和结果一目了然。今天特地去找了一下是利用什么来实现的。网上搜了一会，大概明白了如何实现，下面是预览效果(请耐心等待一下，可能加载有点慢)： &emsp;&emsp;下面来说说实现的步骤： 进入jsfiddle官网注册jsfiddle账号&emsp;&emsp;然后可以看到如下页面： 将html、css、js分别写在指定的位置当中，最后一个框result是显示效果的；依次点击Run、Save，然后在embed中可以得到EMBED CODE,这里点击右边的Perfer iframe？，复制代码到你的markdown中。在Embed的TABS中可以勾选你想要显示的内容。然后在你复制的代码中也可以进行编辑：1&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;//jsfiddle.net/akaziki/9msfwc6w/embedded/html,css,result/&quot; allowfullscreen=&quot;allowfullscreen&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &emsp;&emsp;jsfiddle.net/akaziki/9msfwc6w是你的代码链接，html,css,result是要显示的内容和顺序。 可参考网站：http://doc.jsfiddle.net/","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://akaziki.github.io/tags/博客/"},{"name":"Jsfiddle","slug":"Jsfiddle","permalink":"http://akaziki.github.io/tags/Jsfiddle/"}]},{"title":"CSS选择器的权重问题","slug":"CSS选择器的权重问题","date":"2017-10-11T02:06:20.000Z","updated":"2017-11-02T12:41:36.000Z","comments":true,"path":"2017/10/11/CSS选择器的权重问题/","link":"","permalink":"http://akaziki.github.io/2017/10/11/CSS选择器的权重问题/","excerpt":"正文：&emsp;&emsp;css选择器的权重问题一直以来都是困扰我的一件事情。为了解决选择器能如期地修改样式，我总是在想要用的选择器前边加上多个选择器以提高优先级。可是这样做有个缺点，就是下次你要重新再修改样式时需要添加更高优先级的选择器。另一方面就是代码冗余的问题，盲目地添加选择器只会提高代码的混乱度。为此我重新系统地学习了一下关于各个选择器的权值。下面是各个选择器的权重： 通配选择符的权值 0,0,0,0标签的权值为 0,0,0,1类的权值为 0,0,1,0属性选择的权值为 0,0,1,1 0,0,1,0伪类选择的权值为 0,0,1,0伪对象选择的权值为 0,0,0,1ID的权值为 0,1,0,0!important的权值为最高 1,0,0,0 &emsp;&emsp;了解了各个选择器的权值后，就可以更加清晰地知道自己该用哪些选择器了。这里说一下选择器的使用规则，就是选择器的权值加到一起，权值大的优先。如果权值相同，后定义的优先。所以在使用选择器的时候，应进行适当的计算，避免css的重复定义以造成代码的冗余,还有就是不要一味地添加选择器的数量来来提高优先级。","text":"正文：&emsp;&emsp;css选择器的权重问题一直以来都是困扰我的一件事情。为了解决选择器能如期地修改样式，我总是在想要用的选择器前边加上多个选择器以提高优先级。可是这样做有个缺点，就是下次你要重新再修改样式时需要添加更高优先级的选择器。另一方面就是代码冗余的问题，盲目地添加选择器只会提高代码的混乱度。为此我重新系统地学习了一下关于各个选择器的权值。下面是各个选择器的权重： 通配选择符的权值 0,0,0,0标签的权值为 0,0,0,1类的权值为 0,0,1,0属性选择的权值为 0,0,1,1 0,0,1,0伪类选择的权值为 0,0,1,0伪对象选择的权值为 0,0,0,1ID的权值为 0,1,0,0!important的权值为最高 1,0,0,0 &emsp;&emsp;了解了各个选择器的权值后，就可以更加清晰地知道自己该用哪些选择器了。这里说一下选择器的使用规则，就是选择器的权值加到一起，权值大的优先。如果权值相同，后定义的优先。所以在使用选择器的时候，应进行适当的计算，避免css的重复定义以造成代码的冗余,还有就是不要一味地添加选择器的数量来来提高优先级。 其他福利：&emsp;&emsp;很多人本来就对选择器之前的权重关系拎不清，当下，各种CSS3伪类纷至沓来，更迷糊了。 &emsp;&emsp;为了拯救我们这些劳苦命的的页面仔们，国外有人制作了一个很通俗易懂的，大鱼吃小鱼，小鱼吃小虾，小虾吃泥巴的CSS选择器类型与权重关系图： 参考文章：http://www.zhangxinxu.com/wordpress/2012/08/256-class-selector-beat-id-selector/","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://akaziki.github.io/tags/CSS/"}]},{"title":"浅谈EJS","slug":"浅谈EJS","date":"2017-10-09T03:11:14.000Z","updated":"2017-11-02T12:42:44.000Z","comments":true,"path":"2017/10/09/浅谈EJS/","link":"","permalink":"http://akaziki.github.io/2017/10/09/浅谈EJS/","excerpt":"&emsp;&emsp;在知乎看了许多“关于nodejs的模板引擎，如何选择EJS和Jade？”这个问题的回答，对EJS和Jade有了大概的的初步印象，也基本了解到了swig这个模板。EJS的结构更像HTML，但是Jade更加简洁，swig的特性还是不大了解。鉴于自己处于入门级，然后选择EJS的人也比较多，所以就找了EJS的一些资料进行学习。下面是一些个人的理解和一些供自己以后参考的笔记。 什么是EJS&emsp;&emsp;简单来说EJS就是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。 为什么要使用EJS&emsp;&emsp;与最初的JavaScript相比较，一些不太了解你的代码的人可以更容易地通过EJS模板代码看得懂你的代码。 &emsp;&emsp;这里我找了一个比较浅显易懂的例子： &emsp;&emsp;这是用javascript实现的代码 12345678910var html = &quot;&lt;h1&gt;&quot;+data.title+&quot;&lt;/h1&gt;&quot;html += &quot;&lt;ul&gt;&quot;for(var i=0; i&lt;data.supplies.length; i++) &#123; html += &quot;&lt;li&gt;&lt;a href=&apos;supplies/&quot;+data.supplies[i]+&quot;&apos;&gt;&quot; html += data.supplies[i]+&quot;&lt;/a&gt;&lt;/li&gt;&quot;&#125;html += &quot;&lt;/ul&gt;&quot;","text":"&emsp;&emsp;在知乎看了许多“关于nodejs的模板引擎，如何选择EJS和Jade？”这个问题的回答，对EJS和Jade有了大概的的初步印象，也基本了解到了swig这个模板。EJS的结构更像HTML，但是Jade更加简洁，swig的特性还是不大了解。鉴于自己处于入门级，然后选择EJS的人也比较多，所以就找了EJS的一些资料进行学习。下面是一些个人的理解和一些供自己以后参考的笔记。 什么是EJS&emsp;&emsp;简单来说EJS就是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。 为什么要使用EJS&emsp;&emsp;与最初的JavaScript相比较，一些不太了解你的代码的人可以更容易地通过EJS模板代码看得懂你的代码。 &emsp;&emsp;这里我找了一个比较浅显易懂的例子： &emsp;&emsp;这是用javascript实现的代码 12345678910var html = &quot;&lt;h1&gt;&quot;+data.title+&quot;&lt;/h1&gt;&quot;html += &quot;&lt;ul&gt;&quot;for(var i=0; i&lt;data.supplies.length; i++) &#123; html += &quot;&lt;li&gt;&lt;a href=&apos;supplies/&quot;+data.supplies[i]+&quot;&apos;&gt;&quot; html += data.supplies[i]+&quot;&lt;/a&gt;&lt;/li&gt;&quot;&#125;html += &quot;&lt;/ul&gt;&quot; &emsp;&emsp;最终要实现的效果如下 &emsp;&emsp;但是上面的代码看起来很乱，虽然实现了功能，但是不容易让人弄懂，而且HTML结构完全在JavaScript代码中丢失。 &emsp;&emsp;下面学习EJS同样实现上面的功效，它的工作原理如下： &emsp;&emsp;使用EJS来找回你的明确、维护性良好的HTML代码结构。注:data是json对象，不能使json字符串。 &emsp;&emsp;在HTML中引入EJS,以使javascript能够使用它，引入EJS的语句如下： &lt;script type=&quot;text/javascript&quot; src=&quot;/js/ejs.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;创建一个EJS模板,命名为cleaning.ejs文件，内容如下 12345678&lt;h1&gt;&lt;%=title %&gt;&lt;/h1&gt;&lt;ul&gt;&lt;% for ( var i=0; i&lt;supplies.length; i++) &#123; %&gt; &lt;li&gt; &lt;a href= &apos;supplies/&lt;%=supplies[i] %&gt;&apos; &gt;&lt;%= supplies[i] %&gt;&lt;/a&gt; &lt;/li&gt;&lt;% &#125; %&gt;&lt;/ul&gt; &emsp;&emsp;HTML文档如下，引入EJS,并创建EJS对象，然后调用EJS对象成员函数解析JSON对象到模板中。 123456789101112131415161718&lt; html &gt;&lt; head &gt;&lt; script type = &quot;text/javascript&quot; src = &quot;/js/ejs.js&quot; &gt;&lt;/ script &gt;&lt; script type = &quot;text/javascript&quot; &gt; function myfunction()&#123; var data=&apos;&#123;&quot;title&quot;:&quot;cleaning&quot;,&quot;supplies&quot;:[&quot;mop&quot;,&quot;broom&quot;,&quot;duster&quot;]&#125;&apos; var html = new EJS(&#123;url: &apos;cleaning.ejs&apos;&#125;).render(JSON.parse(data)) //JSON.parse(data) 把JSON字符串解析为原生的javascript值 alert(html); document.getElementById(&quot;div1&quot;).innerHTML=html; &#125;&lt;/ script &gt;&lt;/ head &gt;&lt; body &gt; &lt;button onclick = &quot;myfunction()&quot; &gt;点击&lt;/button&gt; &lt; div id = &quot;div1&quot; &gt;&lt;/ div &gt;&lt;/ body&gt;&lt; html &gt; &emsp;&emsp;从上面这个例子我们可以看到EJS模板的基本用法 EJS的语法和功能：1、缓存功能，能够缓存已经解析好的html模版； 2、&lt;% code %&gt;用于执行其中javascript代码，如： &lt;% alert(&apos;hello world&apos;) %&gt; 3、&lt;%= code %&gt;会对code进行html转义； &emsp;&emsp;下面是一些语法例子： 12345678&lt;!-- 把title里面存的值给显示出来在h1中。 --&gt;&lt;h1&gt;&lt;% =title %&gt;&lt;/h1&gt;&lt;!-- 把hello world显示在h1中。 --&gt;&lt;p&gt;&lt;% =&apos;hello world&apos; %&gt;&lt;/p&gt;&lt;!-- 把hello world变粗，然后显示在h1中。 --&gt;&lt;h1&gt;&lt;% =&apos;&lt;b&gt;hello world&lt;/b&gt;&apos; %&gt;&lt;/h1&gt; 4、&lt;%- code %&gt;将不会进行转义；这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。 &lt;h1&gt;&lt;%-title %&gt;asd&lt;/h1&gt; 最后显示asd，及显示原网页 &lt;p&gt;&lt;% #&apos;hello world&apos; %&gt;asd&lt;/p&gt; 最后显示asd，及显示原网页 5、EJS里，默认的闭合标记是 &lt;% .. %&gt;，我们也可以通过app.set()定义自己的标签。例如： 123456app.set(&quot;view options&quot;,&#123; &quot;open&quot;:&quot;&#123;&#123;&quot;, &quot;close&quot;:&quot;&#125;&#125;&quot;&#125;); 6、一些辅助函数，用于模版中使用(留着用来供查阅使用) 1)、first，返回数组的第一个元素；2)、last，返回数组的最后一个元素；3)、capitalize，返回首字母大写的字符串；4)、downcase，返回字符串的小写；5)、upcase，返回字符串的大写；6)、sort，排序（Object.create(obj).sort()？）；7)、sort_by:’prop’，按照指定的prop属性进行升序排序；8)、size，返回长度，即length属性，不一定非是数组才行；9)、plus:n，加上n，将转化为Number进行运算；10)、minus:n，减去n，将转化为Number进行运算；11)、times:n，乘以n，将转化为Number进行运算；12)、divided_by:n，除以n，将转化为Number进行运算；13)、join:’val’，将数组用’val’最为分隔符，进行合并成一个字符串；14)、truncate:n，截取前n个字符，超过长度时，将返回一个副本15)、truncate_words:n，取得字符串中的前n个word，word以空格进行分割；16)、replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；17)、prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；18)、append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；19)、map:’prop’，返回对象数组中属性为prop的值组成的数组；20)、reverse，翻转数组或字符串；21)、get:’prop’，取得属性为’prop’的值；22)、json，转化为json格式字符串 7、利用&lt;%- include filename %&gt;加载其他页面模版； 使用创建好的EJS模板&emsp;&emsp;基于我们之前写的模拟生成一个EJS对象 new EJS({url: &apos;cleaning.ejs&apos;}) &emsp;&emsp;对象有下面两个成员函数 ejs.compile(str, options); //将返回内部解析好的Function函数 ejs.render(str, options); //返回经过解析的字符串 &emsp;&emsp;ejs的render函数有两个参数 第一个是字符串，第二个是可选的对象，和其他javascript模版一样需要渲染的数据也是包含在option对象中的。 ejs.render(str,option); // 渲染字符串 str 一般是通过nodejs文件系统的readfile方法读取 ejs.render(str,{data : user_data // 需要渲染的数据}); 其中options的一些参数为: 1、cache：是否缓存解析后的模版，需要filename作为key；2、filename：模版文件名；3、scope：complile后的Function执行所在的上下文环境；4、debug：标识是否是debeg状态，debug为true则会输出生成的Function内容；5、compileDebug：标识是否是编译debug，为true则会生成解析过程中的跟踪信息，用于调试；6、client，标识是否用于浏览器客户端运行，为true则返回解析后的可以单独运行的Function函数；7、open，代码开头标记，默认为’&lt;%’；8、close，代码结束标记，默认为’%&gt;’；9、其他的一些用于解析模版时提供的变量。 EJS的应用场所1、用JavaScript创建HTML字符串 正如我们在新手教程中所讨论的，在JavaScript中拼字符串的缺点是可维护性不好。当你在JavaScript中将这些字符串拼到一起时，很难看出你正在写的HTML是什么---你页面展现的结构过于混乱。而使用EJS模板可以让你通过代码的空行和缩进来清楚地展现出你的HTML。 2、基于WebService的AJAX网站开发 EJS可以接收WebService异步传送过来的JSON格式的数据，将这种数据直接传入你的模板里，然后将结果插入到你的页面中。你所需要做的只是通过以下代码 new EJS({url: &apos;comments.ejs&apos;}).update(&apos;element_id&apos;, &apos;/comments.json&apos;)","categories":[],"tags":[{"name":"Ejs","slug":"Ejs","permalink":"http://akaziki.github.io/tags/Ejs/"}]},{"title":"HEXO添加评论系统","slug":"hexo添加评论系统","date":"2017-10-08T05:28:54.000Z","updated":"2017-11-02T12:41:34.000Z","comments":true,"path":"2017/10/08/hexo添加评论系统/","link":"","permalink":"http://akaziki.github.io/2017/10/08/hexo添加评论系统/","excerpt":"(10月9号更新…)emmmmm…特意过来更新一下。因为一直都是在墙外，所以测试的时候没有考虑到Disqus国内能不能用的问题。昨天朋友说看不到我的评论系统才醒悟过来。所以现在国内基本没有可以直接用的评论系统了，然后朋友就自己搭建了一个(膜拜大佬)，还写了篇博文来说明具体步骤。奈何我是github page，不能直接使用他的评论系统。有兴趣的话可以到我朋友博客看看。 &emsp;&emsp;文章主要描述了hexo静态博客框架通过Disqus来添加评论功能的详细步骤。之所以选择disqus的原因是多说、网易云跟帖已经停止运营了，然后畅言需要进行ICP备案(我有句mmp…)。剩下的选择只有disqus了，而且disqus不需要主题支持，hexo的_config.yml本身就可以进行配置。 &emsp;&emsp;以我自己博客所选主题yilia为例，在 themes/yilia/路径下的_config.yml文件中，disqus设置为真disqus: true，并添加disqus相关项 disqus_shortname: akaziki(你自己的disqus的website name)，akaziki为你在Disqus上配置的site的shorname（接下来会配置shortname），Disqus的配置步骤如下:","text":"(10月9号更新…)emmmmm…特意过来更新一下。因为一直都是在墙外，所以测试的时候没有考虑到Disqus国内能不能用的问题。昨天朋友说看不到我的评论系统才醒悟过来。所以现在国内基本没有可以直接用的评论系统了，然后朋友就自己搭建了一个(膜拜大佬)，还写了篇博文来说明具体步骤。奈何我是github page，不能直接使用他的评论系统。有兴趣的话可以到我朋友博客看看。 &emsp;&emsp;文章主要描述了hexo静态博客框架通过Disqus来添加评论功能的详细步骤。之所以选择disqus的原因是多说、网易云跟帖已经停止运营了，然后畅言需要进行ICP备案(我有句mmp…)。剩下的选择只有disqus了，而且disqus不需要主题支持，hexo的_config.yml本身就可以进行配置。 &emsp;&emsp;以我自己博客所选主题yilia为例，在 themes/yilia/路径下的_config.yml文件中，disqus设置为真disqus: true，并添加disqus相关项 disqus_shortname: akaziki(你自己的disqus的website name)，akaziki为你在Disqus上配置的site的shorname（接下来会配置shortname），Disqus的配置步骤如下: &emsp;&emsp;Disqus网址，注册完账号登录后点击左上角Home跳转到主页，然后点GET STARTED，再次跳转后选择I want to install Disqus on my site，然后在新页面中填写你的website name、type和language，如下图： &emsp;&emsp;创建成功后，在新页面点击Install Disqus，Platform选择为Universal Code，拉到页面最下面点击按钮即可。 &emsp;&emsp;然后点击Configure Disqus，将Website Name改为你想要的名称，我的为akaziki，URL设置为你的Github page地址，然后完成。 &emsp;&emsp;基本上所有步骤都进行完了，你可以依次执行clean，generate和deploy来部署。","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://akaziki.github.io/tags/博客/"},{"name":"HEXO","slug":"HEXO","permalink":"http://akaziki.github.io/tags/HEXO/"}]},{"title":"MarkDown使用小技巧","slug":"MarkDown使用小技巧","date":"2017-10-02T10:37:30.000Z","updated":"2017-11-02T12:42:00.000Z","comments":true,"path":"2017/10/02/MarkDown使用小技巧/","link":"","permalink":"http://akaziki.github.io/2017/10/02/MarkDown使用小技巧/","excerpt":"写作目的在看了一些MarkDown的入门语法之后，发现许多的文档对一些比较细微的问题缺乏解释。所以打算再进行补充一下。 目标读者使用MarkDown仅仅为了排版出更好看的文章，而不关注技术细节，不懂HTML的用户。 1、首行缩进写文章时，我们常常希望能够首行缩进，这时可以在段首加入&ensp;来输入一个空格.加入&emsp;来输入两个空格。 示例文本1&amp;emsp;&amp;emsp;一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！&quot;","text":"写作目的在看了一些MarkDown的入门语法之后，发现许多的文档对一些比较细微的问题缺乏解释。所以打算再进行补充一下。 目标读者使用MarkDown仅仅为了排版出更好看的文章，而不关注技术细节，不懂HTML的用户。 1、首行缩进写文章时，我们常常希望能够首行缩进，这时可以在段首加入&ensp;来输入一个空格.加入&emsp;来输入两个空格。 示例文本1&amp;emsp;&amp;emsp;一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！&quot; 效果 &emsp;&emsp;一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！ 2、插入代码插入代码的方式有两种 在每行代码前加入4个空格或者添加一个制表符（TAB键） 在代码两侧添加三个反引号‘```’。 两种方法都有需要注意的地方，很多入门文档未能提及。 2.1 方式1其缩进是相对于当前格式状态下的。 示例文本 列表项 列表项[TAB][TAB]printf(“hello world!”); 效果 列表项 列表项printf(&quot;hello world!&quot;); 在列表项状态下，需要输入两次TAB键(制表符)才能以代码格式插入(本主题下的代码颜色显示有点怪异)。 2.2 方式2反引号最好在代码的前后行添加，而不是直接加在代码两边。 示例文本 ```var sta = “swift你好，我叫akaziki”println(sta)``` 效果12var sta = &quot;swift你好，我叫akaziki&quot;println(sta) 3、添加空行添加空行可以结束先前的格式状态。个人建议在改变格式时，均添加一个空行。 示例文本 >引用状态[空行]###标题状态[空行]------[空行]- 列表状态- 列表状态 效果 引用状态 标题状态 列表状态 列表状态 4、其他 普通段落尽量不用空格或制表符来缩进，即使使用它们后得到的效果看似是对的。 [数字] + ‘.’ + [空格] 的形式会呼出有序的项目列表。因此如果你在正文中恰好出现这种形式，那么可以在‘.’的前面加上‘\\’来避免出现有序列表。 2017-10-02","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://akaziki.github.io/tags/Markdown/"},{"name":"博客","slug":"博客","permalink":"http://akaziki.github.io/tags/博客/"}]}]}