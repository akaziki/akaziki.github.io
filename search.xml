<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WSL环境配置]]></title>
    <url>%2F2018%2F11%2F28%2FWSL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[zsh和oh-my-zsh12sudo apt install zshsh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 设置terminal的shell环境默认为zsh，输入以下命令1chsh -s /bin/zsh 这条命令的 ` 是键盘tab上面的那个 ,接下来重启终端 zsh颜色主题和终端颜色主题 (Color Theme)要配置两个部分：zsh主题（zsh theme）和终端的颜色主题（Color Theme） 由于使用了oh-my-zsh，修改zsh的主题很容易，只要编辑~/.zshrc文件，找到ZSH_THEME一行，改为agnoster即可 但是Windows默认终端的Color Theme改起来比较费劲，需要使用一个叫做colortool的工具。他是微软自带的一个修改终端配色方案的工具首先在这里 下载 下载colortool.zip并解压后，进入文件夹，按住shift并点击右键选择在此处打开Powershell窗口 在其中输入 1.\colortool.exe -d solarized_dark 回车后，关闭这个新打开的Powershell窗口，回到之前的WSL窗口，输入如下命令以使zsh配置生效: 1source ~/.zshrc 安装 Fira Code字体点击这里下载：https://raw.githubusercontent.com/tonsky/FiraCode/master/distr/ttf/FiraCode-Retina.ttf 插件推荐zoh-my-zsh自带插件，开启即可 快捷访问常用目录的插件，可以让你非常方便的访问经常要使用的目录 比如我经常使用 cd ~/workspace/mpa-web，安装后可以z m[tab][return]来快速访问 PS: 刚装上后需要输入几次正常的 cd 命令之后他才能搜集到足够的信息整理出常用路径 doh-my-zsh自带插件，开启即可 使用命令d列出历史纪录中10个最近的目录，输入数字可以直接跳转在跳来跳去配置环境时很有用，因为你往往不记得刚才的配置文件在哪个路径里面 colored-man-pagesoh-my-zsh自带插件，开启即可给man命令中的文档加上一些语法高亮。man命令可以用来查看其他命令的文档，比如man git就会展示git命令的介绍。使用这个插件之后可以让这个文档可读性稍微好一点点 syntax-highlighting &amp; zsh-autosuggestions插件repo https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md 这两个插件可以让你在终端输入命令时有语法高亮和自动补全。虽然放在了最后，但是这两个插件才是zsh真正的killer plugin :p 使用同样很简单，先通过如下命令安装： 1cd ~/ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 然后和上面一样，在 .zshrc 加上插件名即可。 上面所有插件都打开的话，~/.zshrc中应该这样写: 1plugins=(z d colored-man-pages zsh-autosuggestions zsh-syntax-highlighting) 安装node首先安装必要的包。12sudo apt-get updatesudo apt-get install build-essential libssl-dev 然后安装nvm的脚本，有两种方法curl或wget通过curl: 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash 通过wget: 1wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash 检查安装及使用注意，此处需要重启terminal终端才能生效。使用nvm –help查看是否安装成功。使用nvm ls查看已经安装的版本。使用nvm ls-remote查看所有远端版本。使用nvm install安装某个版本，如nvm install v5.3.0。 使用nvm use切换到某个版本，如nvm use v5.3.0使用5.3.0，nvm use system使用系统版本。 设置镜像源为淘宝1npm config set registry https://registry.npm.taobao.org 配置别名1vim ~/.bashrc 在文件中添加，如下： 123alias AD7='cd ~/GS700E/android/kernel/arch/arm64/boot/dts'alias AD5='cd ~/AD500A/android/kernel/arch/arm/boot/dts'alias GS7='cd ~/AD700A/android/kernel/arch/arm64/boot/dts' 保存退出,然后执行： 1source ~/.bashrc zsh配置别名1vim ~/.zshrc 在文件中添加，如下： 123alias AD7='cd ~/GS700E/android/kernel/arch/arm64/boot/dts'alias AD5='cd ~/AD500A/android/kernel/arch/arm/boot/dts'alias GS7='cd ~/AD700A/android/kernel/arch/arm64/boot/dts' 保存退出,然后执行： 1source ~/.zshrc OpenSSH Server 设定首先，先使用 ssh-keygen 产生key，接着打开sshd_config 來编辑设定： 12sudo /usr/bin/ssh-keygen -Asudo vim /etc/ssh/sshd_config 启动OpenSSH Server ： 1sudo /etc/init.d/ssh start 配置 VSCode 终端默认使用 WSL 的 bash1234&#123; "terminal.integrated.shell.windows": "C:\\Windows\\System32\\wsl.exe", "terminal.integrated.fontFamily": "Menlo for Powerline"//字体&#125; 如果要调用 32 位进程，需要配置使用 Sysnative：C:\\Windows\\sysnative\\bash.exe 如果 VSCode 是 64 位版本，可以直接使用：C:\\WINDOWS\\System32\\bash.exe 或者 C:\\WINDOWS\\System32\\wsl.exe]]></content>
      <tags>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易的cocos_toast_component]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%AE%80%E6%98%93%E7%9A%84cocos-toast-component%2F</url>
    <content type="text"><![CDATA[cocos_toast_component 代码地址：https://github.com/akaziki/cocos_toast_component 一个简单的 tost 组件，用法： 12var Toast = reqire('Toast.js')Toast(text,&#123;[gravity],[duration],[bg_color]&#125;) text:要显示的字符串 gravity(可选):位置，String 类型，可选值(‘CENTER’,’TOP’,’BOTTOM’),默认为’CENTER’ duration(可选):时间，Number 类型，单位为秒，默认 1s bg_color(可选):颜色，cc.color 类型，默认 cc.color(102, 102, 102, 200)]]></content>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中条件判断优雅写法]]></title>
    <url>%2F2018%2F04%2F05%2FJS%E4%B8%AD%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，本文旨在书写更为优雅的js判断。 常见写法if/else先看一段代码 12345678910111213141516171819202122232425/** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */const onButtonClick = (status)=&gt;&#123; if(status == 1)&#123; sendLog(&apos;processing&apos;) jumpTo(&apos;IndexPage&apos;) &#125;else if(status == 2)&#123; sendLog(&apos;fail&apos;) jumpTo(&apos;FailPage&apos;) &#125;else if(status == 3)&#123; sendLog(&apos;fail&apos;) jumpTo(&apos;FailPage&apos;) &#125;else if(status == 4)&#123; sendLog(&apos;success&apos;) jumpTo(&apos;SuccessPage&apos;) &#125;else if(status == 5)&#123; sendLog(&apos;cancel&apos;) jumpTo(&apos;CancelPage&apos;) &#125;else &#123; sendLog(&apos;other&apos;) jumpTo(&apos;Index&apos;) &#125;&#125; 通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，下面是这段代码的switch改写方案 switch1234567891011121314151617181920212223242526272829/** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */const onButtonClick = (status)=&gt;&#123; switch (status)&#123; case 1: sendLog(&apos;processing&apos;) jumpTo(&apos;IndexPage&apos;) break case 2: case 3: sendLog(&apos;fail&apos;) jumpTo(&apos;FailPage&apos;) break case 4: sendLog(&apos;success&apos;) jumpTo(&apos;SuccessPage&apos;) break case 5: sendLog(&apos;cancel&apos;) jumpTo(&apos;CancelPage&apos;) break default: sendLog(&apos;other&apos;) jumpTo(&apos;Index&apos;) break &#125;&#125; 这种写法看起来比if/else清晰 一元判断存到Object里12345678910111213141516171819const actions = &#123; &apos;1&apos;: [&apos;processing&apos;,&apos;IndexPage&apos;], &apos;2&apos;: [&apos;fail&apos;,&apos;FailPage&apos;], &apos;3&apos;: [&apos;fail&apos;,&apos;FailPage&apos;], &apos;4&apos;: [&apos;success&apos;,&apos;SuccessPage&apos;], &apos;5&apos;: [&apos;cancel&apos;,&apos;CancelPage&apos;], &apos;default&apos;: [&apos;other&apos;,&apos;Index&apos;],&#125;/** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消 */const onButtonClick = (status)=&gt;&#123; let action = actions[status] || actions[&apos;default&apos;], logName = action[0], pageName = action[1] sendLog(logName) jumpTo(pageName)&#125; 上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况 存到Map里1234567891011121314151617const actions = new Map([ [1, [&apos;processing&apos;,&apos;IndexPage&apos;]], [2, [&apos;fail&apos;,&apos;FailPage&apos;]], [3, [&apos;fail&apos;,&apos;FailPage&apos;]], [4, [&apos;success&apos;,&apos;SuccessPage&apos;]], [5, [&apos;cancel&apos;,&apos;CancelPage&apos;]], [&apos;default&apos;, [&apos;other&apos;,&apos;Index&apos;]]])/** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */const onButtonClick = (status)=&gt;&#123; let action = actions.get(status) || actions.get(&apos;default&apos;) sendLog(action[0]) jumpTo(action[1])&#125; 这样写用到了es6里的Map对象。Map对象和Object对象有以下区别： 一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键 一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认 多元判断我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份： 123456789101112131415161718192021222324252627282930313233343536/** * 按钮点击事件 * @param &#123;number&#125; status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团 * @param &#123;string&#125; identity 身份标识：guest客态 master主态 */const onButtonClick = (status,identity)=&gt;&#123; if(identity == &apos;guest&apos;)&#123; if(status == 1)&#123; //do sth &#125;else if(status == 2)&#123; //do sth &#125;else if(status == 3)&#123; //do sth &#125;else if(status == 4)&#123; //do sth &#125;else if(status == 5)&#123; //do sth &#125;else &#123; //do sth &#125; &#125;else if(identity == &apos;master&apos;) &#123; if(status == 1)&#123; //do sth &#125;else if(status == 2)&#123; //do sth &#125;else if(status == 3)&#123; //do sth &#125;else if(status == 4)&#123; //do sth &#125;else if(status == 5)&#123; //do sth &#125;else &#123; //do sth &#125; &#125;&#125; 从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？ 将condition拼接成字符串存到Map里1234567891011121314151617181920212223const actions = new Map([ [&apos;guest_1&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;guest_2&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;guest_3&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;guest_4&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;guest_5&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;master_1&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;master_2&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;master_3&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;master_4&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;master_5&apos;, ()=&gt;&#123;/*do sth*/&#125;], [&apos;default&apos;, ()=&gt;&#123;/*do sth*/&#125;],])/** * 按钮点击事件 * @param &#123;string&#125; identity 身份标识：guest客态 master主态 * @param &#123;number&#125; status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团 */const onButtonClick = (identity,status)=&gt;&#123; let action = actions.get(`$&#123;identity&#125;_$&#123;status&#125;`) || actions.get(&apos;default&apos;) action.call(this)&#125; 上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用 当然上述代码如果用Object对象来实现也是类似的： 将condition拼接成字符串存到Object里12345678910const actions = &#123; &apos;guest_1&apos;:()=&gt;&#123;/*do sth*/&#125;, &apos;guest_2&apos;:()=&gt;&#123;/*do sth*/&#125;, //....&#125;const onButtonClick = (identity,status)=&gt;&#123; let action = actions[`$&#123;identity&#125;_$&#123;status&#125;`] || actions[&apos;default&apos;] action.call(this)&#125; 如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key： 将condition存为Object存到Map里12345678910const actions = new Map([ [&#123;identity:&apos;guest&apos;,status:1&#125;,()=&gt;&#123;/*do sth*/&#125;], [&#123;identity:&apos;guest&apos;,status:2&#125;,()=&gt;&#123;/*do sth*/&#125;], //...])const onButtonClick = (identity,status)=&gt;&#123; let action = [...actions].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this))&#125; 这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key 我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样： 12345678const actions = new Map([ [&#123;identity:&apos;guest&apos;,status:1&#125;,()=&gt;&#123;/* functionA */&#125;], [&#123;identity:&apos;guest&apos;,status:2&#125;,()=&gt;&#123;/* functionA */&#125;], [&#123;identity:&apos;guest&apos;,status:3&#125;,()=&gt;&#123;/* functionA */&#125;], [&#123;identity:&apos;guest&apos;,status:4&#125;,()=&gt;&#123;/* functionA */&#125;], [&#123;identity:&apos;guest&apos;,status:5&#125;,()=&gt;&#123;/* functionB */&#125;], //...]) 好一点的写法是将处理逻辑函数进行缓存： 1234567891011121314151617const actions = ()=&gt;&#123; const functionA = ()=&gt;&#123;/*do sth*/&#125; const functionB = ()=&gt;&#123;/*do sth*/&#125; return new Map([ [&#123;identity:&apos;guest&apos;,status:1&#125;,functionA], [&#123;identity:&apos;guest&apos;,status:2&#125;,functionA], [&#123;identity:&apos;guest&apos;,status:3&#125;,functionA], [&#123;identity:&apos;guest&apos;,status:4&#125;,functionA], [&#123;identity:&apos;guest&apos;,status:5&#125;,functionB], //... ])&#125;const onButtonClick = (identity,status)=&gt;&#123; let action = [...actions()].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this))&#125; 这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的 将condition写作正则存到Map里1234567891011121314const actions = ()=&gt;&#123; const functionA = ()=&gt;&#123;/*do sth*/&#125; const functionB = ()=&gt;&#123;/*do sth*/&#125; return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], //... ])&#125;const onButtonClick = (identity,status)=&gt;&#123; let action = [...actions()].filter(([key,value])=&gt;(key.test(`$&#123;identity&#125;_$&#123;status&#125;`))) action.forEach(([key,value])=&gt;value.call(this))&#125; 这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写 12345678910111213141516const actions = ()=&gt;&#123; const functionA = ()=&gt;&#123;/*do sth*/&#125; const functionB = ()=&gt;&#123;/*do sth*/&#125; const functionC = ()=&gt;&#123;/*send log*/&#125; return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], [/^guest_.*$/,functionC], //... ])&#125;const onButtonClick = (identity,status)=&gt;&#123; let action = [...actions()].filter(([key,value])=&gt;(key.test(`$&#123;identity&#125;_$&#123;status&#125;`))) action.forEach(([key,value])=&gt;value.call(this))&#125; 也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，就可以有更多的想法了 总结本文介绍了8种逻辑判断写法，包括： if/else switch 一元判断时：存到Object里 一元判断时：存到Map里 多元判断时：将condition拼接成字符串存到Map里 多元判断时：将condition拼接成字符串存到Object里 多元判断时：将condition存为Object存到Map里 多元判断时：将condition写作正则存到Map里]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git详细讲解]]></title>
    <url>%2F2017%2F11%2F30%2Fgit%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[git工作流程 Workspace：工作区 程序员进行开发改动的地方，是你当前看到的，也是最新的。 平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。 Index / Stage：暂存区 .git目录下的index文件, 暂存区会记录git add添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用git status查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。 当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过git add先提交到暂存区，被git管理。 Repository：仓库区（或本地仓库） 保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。 git commit后同步index的目录树到本地仓库，方便从下一步通过git push同步本地仓库与远程仓库的同步。 Remote：远程仓库 远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。 小结 任何对象都是在工作区中诞生和被修改； 任何修改都是从进入index区才开始被版本控制； 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹； 与协作者分享本地的修改，可以把它们push到远程仓库来共享。 下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。 常用Git命令 HEAD在掌握具体命令前，先理解下HEAD。 HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。 add add相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。 git add . 添加当前目录的所有文件到暂存区 git add [dir] 添加指定目录到暂存区，包括子目录 git add [file1] 添加指定文件到暂存区 commit commit相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。 git commit -m [message] 提交暂存区到本地仓库,message代表说明信息 git commit [file1] -m [message] 提交暂存区的指定文件到本地仓库 git commit –amend -m [message] 使用一次新的commit，替代上一次提交 branch 涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地分支和远程分支 git branch [branch-name] 新建一个分支，但依然停留在当前分支 git checkout -b [branch-name] 新建一个分支，并切换到该分支 git branch –track [branch][remote-branch] 新建一个分支，与指定的远程分支建立追踪关系 git checkout [branch-name] 切换到指定分支，并更新工作区 git branch -d [branch-name] 删除分支 git push origin –delete [branch-name] 删除远程分支 关于分支的操作虽然比较多，但都比较简单好记。 merge merge命令把不同的分支合并起来。如上图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。 git fetch [remote] merge之前先拉一下远程仓库最新代码 git merge [branch] 合并指定分支到当前分支 一般在merge之后，会出现conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。如下图所示，需要手动解除。 rebase rebase又称为衍合，是合并的另外一种选择。 在开始阶段，我们处于new分支上，执行git rebase dev，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。git rebase dev，通俗的解释就是new分支想站在dev的肩膀上继续下去。rebase也需要手动解决冲突。 rebase与merge的区别 现在我们有这样的两个分支,test和master，提交如下： 123 D---E test /A---B---C---F master复制代码 在master执行git merge test,然后会得到如下结果： 123 D--------E / /A---B---C---F----G test, master复制代码 在master执行git rebase test，然后得到如下结果： 1A---B---D---E---C&apos;---F&apos; test, master复制代码 可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。 如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge reset reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。 git reset —soft [commit] 只改变提交点，暂存区和工作目录的内容都不改变 git reset —mixed [commit] 改变提交点，同时改变暂存区的内容 git reset —hard [commit] 暂存区、工作区的内容都会被修改到与提交点完全一致的状态 git reset –hard HEAD 让工作区回到上次提交时的状态 revert git revert用一个新提交来消除一个历史提交所做的任何修改。 revert与reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 push上传本地仓库分支到远程仓库分支，实现同步。 git push [remote][branch] 上传本地指定分支到远程仓库 git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突 git push [remote] –all 推送所有分支到远程仓库 其他命令 git status 显示有变更的文件 git log 显示当前分支的版本历史 git diff 显示暂存区和工作区的差异 git diff HEAD 显示工作区与当前分支最新commit之间的差异 git cherry-pick [commit] 选择一个commit，合并进当前分支 以上就是关于Git的一些常用命令及详细阐述，相信能对Git有一个初步的认识。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记-四]]></title>
    <url>%2F2017%2F11%2F08%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[升级vue2.0 为什么要升级Vue2.0呢？个人觉得以下改变比较吸引人： 更轻更快； 加入虚拟DOM； 更清晰合理的生命周期架构； 更简洁迷你的API； 更符合未来技术规范的设计； 解锁JSX和render函数； ······ ······ vue-migration-helper第一步是使用官方的升级助手vue-migration-helper检测项目代码中可能需要升级的地方。我的小项目代码中共检测出 40 个地方可能需要修改，具体会在下面介绍。 render函数关于render函数，官方是这样说的： 大多数情况下使用基于 template 构件组件都是推荐的，但是 render()函数可以让你在组件中运用更强大的JS。 render() 接收一个叫 createElement 的函数作为形参，它的作用是创建虚拟DOM节点。createElement说明如下： 12345678910111213141516171819202122// 返回虚拟DOM对象createElement( // &#123;String | Object | Function&#125; // 必选项，HTML节点名，自定义组件或者返回这些的函数 'div', // &#123;Object&#125; // 一个对象，描述了用在template中的属性 &#123; // (比如props) &#125;, // &#123;String | Array&#125; // 子节点集合，可以是字符串或者是另一个createElement函数 [ createElement('h1', 'hello world'), createElement(MyComponent, &#123; props: &#123; someProp: 'foo' &#125; &#125;), 'bar' ]) createElement第二个形参详解上文说了这是个描述template中涉及属性的对象，一般来说我们在template中用到的无非：v-bind，v-on，slot，key，ref和某些原生DOM属性，下面是一个较为完整的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; // Same API as `v-bind:class` 'class': &#123; foo: true, bar: false &#125;, // Same API as `v-bind:style` style: &#123; color: 'red', fontSize: '14px' &#125;, // Normal HTML attributes attrs: &#123; id: 'foo' &#125;, // Component props props: &#123; myProp: 'bar' &#125;, // DOM properties domProps: &#123; innerHTML: 'baz' &#125;, // 使用v-on绑定的事件处理函数 on: &#123; click: this.clickHandler &#125;, // 仅用于在自定义组件上绑定原生事件的native描述符 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令 directives: [ &#123; name: 'my-custom-directive', value: '2' expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // The name of a slot if the child of a component slot: 'name-of-slot' // Other special top-level properties key: 'myKey', ref: 'myRef'&#125; 在reder中使用JSX通过 Babel plugin 的支持，现在你可以在vue中使用JSX语法了！（插件地址）它所做的事是将JSX语法的模板转换为render函数： 12345678&lt;div id="foo"&gt;&#123;this.text&#125;&lt;/div&gt;// To the following JavaScript:h('div', &#123; attrs: &#123; id: 'foo' &#125;&#125;, [this.text]) 使用jsx语法编写的render组件： 1234567891011import AnchoredHeading from './AnchoredHeading.vue'new Vue(&#123; el: '#demo', render (h) &#123; return ( &lt;AnchoredHeading level=&#123;1&#125;&gt; &lt;span&gt;Hello&lt;/span&gt; world! &lt;/AnchoredHeading&gt; ) &#125;&#125;) 函数化组件函数化的组件意味着：无状态，非实例，内部没有this： 123456789101112Vue.component('my-component', &#123; functional: true, // To compensate for the lack of an instance, // we are now provided a 2nd context argument. render: function (createElement, context) &#123; // ... &#125;, // Props are optional props: &#123; // ... &#125;&#125;) 具体介绍见：Functional Components。 生命周期生命周期改动比较大，但是升级起来也很容易，具体见下图，有需要照着改就行，不再多说： 组件通信这部分是比较麻烦的，因为之前有用的 $dispatch 和 $broadcast 都被废弃了，组件 events选项也被废弃了，因此这次不得不重构事件部分的代码，原则和注意点如下： 父组件向子组件传递数据使用props，子组件中禁止修改props属性，同时绑定props不再支持双向绑定； 子组件向父组件传递事件使用v-on，子组件中使用$emit(&#39;test&#39;)触发事件，父组件使用v-on:test订阅事件。在自定义组件上订阅原生事件需要加.native修饰符； 兄弟组件或者嵌套比较深的组件之间可以通过新建一个Vue实例作为event hub，当然也推荐使用vuex； 使用$emit触发自定义事件时，事件名称需要以xx-xxx的方式命名； 特别注意： 父组件上不能使用 v-on 订阅其子组件中嵌套组件触发的事件。也就是说 $emit 触发的事件不会像原生事件一样冒泡！ 动画vue2.0对动画做了非常大的更新，原来的transition属性被彻底废弃，取而代之的是更强大的 &lt;transition&gt;元素，以前如果用到了动画必然是要重写的，而且css的命名规则也变了，css也得重写······ filter之前是直接使用vue提供的filterBy 方法，但是在2.0中被废弃了，这部分也得使用计算属性重构。这里需要说明的是，本应用中用到了两层嵌套的 v-for ，第二层的v-for依赖于第一层v-for给的数据，且每一个列表都需要 filter，第一层可以使用计算属性，那么第二层呢？ 答案是用方法： 12345678&lt;!--itemsData是计算属性，itemsFilter是方法--&gt;&lt;ul&gt; &lt;li v-for="items in itemsData"&gt; &lt;ol&gt; &lt;li v-for="item in itemsFilter(items)"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt;&lt;/ul&gt; 其它 v-for中废弃了$index，使用时改为主动声明： 123&lt;ul class="catalog"&gt; &lt;li v-for="(catalog, index) in catalogs" v-on:click="updateCatalog(index)"&gt;&lt;/li&gt;&lt;/ul&gt; v-el 和 v-ref 合并为一个 ref 属性，当元素为自定义组件时ref指向组件，否则指向真实的DOM元素； vue2.0默认输出vue.common.js，common不支持template选项，所以如果你在组件选项中用到了template（通过vue-loader处理过的.vue文件中的template不会有问题）需要在webpack中设置vue的别名； 随着升级2.0，vue生态的其它插件也有升级情况，webpack配置也有变化，建议更换。（ps：yarn第一次的install的时候也很慢···）]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记-三]]></title>
    <url>%2F2017%2F11%2F08%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[部分最基本的功能 点餐菜单部分最基本的功能 组件化项目是由vue-cli生成的vue+webpack模板基础上构建的： 1vue init webpack OrderMenu 目前整个页面分成了8个组件： 八个组件是分层次的：组件分层嵌套。层次的确定有的是根据功能区分，有的是根据渲染的位置和层次。根组件下只包含四个子组件： menu-header：头部结构，包含店铺信息，搜索模块等； menu-item：v-for渲染的list，用于显示菜品； menu-cart：用于显示当前点菜的数量和价格； pic-card：卡片式大图查看组件，在点击菜品缩略图时弹出； 这里组件的划分也不是最合理的，我感觉在功能划分上做的还不够好。 数据设计既然是一个点菜的页面，那么菜品信息必然是主要的部分： 1234567891011121314151617181920212223242526var dishs = [&#123; catalog: "招牌鲜鱼", catalogID: 1100, dishs: [&#123; dishID: 100, dishName: "花鲢", dishDesc: "约350g，原产地当日直供。本店所有鱼均由省重点养殖企业 龙华渔场 提供。", dishPrice: 25, likeNum: 488, imgSrc: require('../img/hualian1.jpg'), isCombo: false, isPromotion: true, searchKey: ["招牌推荐", "鱼类", "热门"], dishNum: 0, imgSrcs: &#123; smallSrcs: [], bigSrcs: [] &#125; &#125;, &#123; // 次分类的下一道菜品 // ... &#125;]&#125;, &#123; // 下一个分类 // ...&#125;]; 在实际中页面渲染可以在客户端或者服务端，在客户端可以通过网络请求获取JSON格式的数据，或者从本地存储（localStorage）中读取，服务端渲染则是计算出可用的HTML和相应的CSS，JS直接返回给客户端。 组件设计这个项目是Vue+webpack，所以可以使用vue-html-loader，vue-loader，vue-style-loader来处理.vue文件，将html模板，组件样式和js都写在一个文件里，实现更完美的组件封装，我觉得这种方式相对于react等框架的一个明显优点就是我们可以更好的管理css。 下面是一个.vue文件的大致结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div id="app"&gt; &lt;menu-header&gt;&lt;/menu-header&gt; &lt;menu-item&gt;&lt;/menu-item&gt; &lt;menu-cart&gt;&lt;/menu-cart&gt; &lt;pic-card&gt;&lt;/pic-card&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MenuHeader from './components/MenuHeader'import MenuItem from './components/MenuItem.vue'import MenuCart from './components/MenuCart.vue'import PicCard from './components/PicCard.vue'import dishsData from './data/dishs.js'export default &#123; data: function() &#123; return &#123; filterKey: '', totalNum: 0, totalPri: 0, lockScroll: false, picCardSrcs: '', showPicCard: false, activeIndex: 0, catalogPos: [], orderedDishs: &#123; pos: [], num: [] &#125; &#125;; &#125;, components: &#123; MenuHeader, MenuItem, MenuCart, PicCard &#125;, created: function() &#123;&#125;, ready: function() &#123;&#125;, methods: &#123; initCatalogPos: function() &#123;&#125;, initOrderedDishs: function() &#123;&#125;, getDishPos: function(id) &#123;&#125; &#125;, watch: &#123; orderedDishs: function(nv, ov) &#123;&#125; &#125;, events: &#123; updateCatalog: function(index) &#123;&#125;, updataFilterkey: function(val) &#123;&#125;, addCart: function(id) &#123;&#125;, minusCart: function(id) &#123;&#125;, toggleScroll: function() &#123;&#125;, openPicCard: function(srcs) &#123;&#125;, closePicCard: function() &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; .vue文件默认生成一个以文件名命名的组件，生成该组件无需调用Vue.component()，组件选项以对象形式输出（export {}）； 在.vue文件中也可以引入Vue（import Vue from &#39;vue&#39;），然后按照常规的方式生成组件： 123456789101112131415161718&lt;script&gt;import Vue from 'vue'Vue.component('tag-combo', &#123; template: '&lt;div class="dish-tag"&gt;' + '&lt;span&gt;套餐&lt;/span&gt;' + '&lt;/div&gt;'&#125;);Vue.component('tag-promotion', &#123; template: '&lt;div class="dish-tag"&gt;' + '&lt;span&gt;特价&lt;/span&gt;' + '&lt;/div&gt;'&#125;);&lt;/script&gt;&lt;style&gt;.dish-tag&#123;&#125;&lt;/style&gt; 调用Vue.component()生成的组件会自动输出，模板选项中不能写类或者ID选择器； 使用 import {TagCombo,TagPromotion} from &#39;./DishTag.vue&#39;引入组件； 如果template模板中有嵌套子组件，组件必须在components选项中注册（先import再注册）； 组件通信在这个项目中主要采用了两种通信方式： PROPS通过props传递数据，这种方式符合Vue数据驱动的理念，但是实现起来比较麻烦： 12345678910111213141516// 父组件中嵌套子组件 menu-header，使用v-bind动态的传递父组件中的数据&lt;div id="app" v-bind:class="&#123;showCart:totalNum&#125;"&gt; &lt;menu-header v-bind:active-index="activeIndex" v-bind:ordered-tips="orderedDishs.num"&gt;&lt;/menu-header&gt;&lt;/div&gt;// 子组件中声明props字段，并同样使用v-bind传递给嵌套的子组件&lt;template&gt; &lt;menu-contents v-bind:active-catalog="activeIndex" v-bind:number-tips="orderedTips"&gt;&lt;/menu-contents&gt;&lt;/template&gt;export default &#123; props: ['activeIndex', 'orderedTips']&#125;// 在子子组件中使用根组件传递过来的数据&lt;span class="num" v-show="numberTips[$index]"&gt;&#123;&#123;numberTips[$index]&#125;&#125;&lt;/span&gt;props: ['activeCatalog', 'numberTips'] 可以看到通过props传递数据需要在中间组件设置过渡字段，看起来略显麻烦，所以我们应该拆分组件时尽量避免深层次的嵌套，这也是最开始我说这个项目组件划分并不完美的原因； 自定义事件项目中还使用了自定义事件来进行通信：在events字段中订阅事件，使用$dispatch()派发事件并传递数据。一般来说我觉得如果嵌套不是特别深最好是还用第一种方法。 当然如果数据结构设计的合理可以大大简化这方面的工作，举个例吧，需求是这样的： 当用户点击加菜或者点菜时，需要在目录相应分类处标识该类别下点了有多少道菜品。 第一版是这样实现的： 在根组件中创建一个字段orderedDishs，它是一个对象，其中num属性是一个数组，数组中代表了各个大类下被点的菜品数量，然后通过props传递给目录组件。 比较麻烦的是：中间需要生成间接props；根组件需要在合适的时候初始化orderedDishs；用户操作时通过dispatch派发事件。所以第二版中我更改了一下数据结构：在菜品信息下每一个大类中新设立一个字段：orderedDishs。它是个数组，里面存放该类别下被点菜品的index。比如：orderedDishs = [0,2,3]代表该类别下第1,3和4道菜被点了。目录渲染已点菜品数量时直接根据orderedDishs的长度进行。 第二版带来的好处在于：相比于以前派发菜品id，现在不用到整个菜品数据中搜索需要的信息（比如价格等），而是直接根据位置信息读取，复杂度变为O(1)。其次，不需要中间组件传递数据，目录直接和菜品信息绑定。 一些感想 Vue的组件没有使用shadowDOM，如果给css样式设置scoped，那么模板内每一个DOM元素会添加类似_v-36628053这样的自定义属性，感觉有点冗余； Vue对camelCase和kebab-case的处理可能最开始会让你不适应； 感觉在移动端浏览器兼容方面还是有些问题（在UC上存在bug）； 往后还需要研究哈vue-router和vuex；]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记(二)]]></title>
    <url>%2F2017%2F11%2F04%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is特性扩展。 组件使用定义123var MyComponent = Vue.extend(&#123; // 选项...&#125;); 注意：Vue构造器的多数选项也可以用在 Vue.extend() 中，不过有两个特例：data 和 el。如果只是将数据直接放入创建函数中，则所有组件实例都会共享同样的数据，有时候这并不是我们希望的（实际上Vue在注册组件时直接给data对象会抛出一个警告，最终会拒绝执行data解析工作），所以可以传入一个函数作为data选项——函数返回一个真正的数据对象。 注册全局注册1234Vue.component(tag, constructor);//like this:Vue.component(&quot;my-component&quot;, MyComponent); tag 表示自定义的组件名，建议使用 小写，用短杠分隔 的规则。component 是创建的组件。注册之后就可以在其它模板中使用此组件。 局部注册局部注册的目的在于:让组件只能用在其它组件内，而不是全局都可以使用。，在实例选项 components 中注册：123456789var Child = Vue.extend(&#123; /* ... */ &#125;);var Parent = Vue.extend(&#123; template: &apos;...&apos;, components: &#123; // &lt;my-component&gt; 只能用在父组件模板内 &apos;my-component&apos;: Child &#125;&#125;); 注册语法糖Vue.component() 注册函数的第二个选项可以直接传入选项对象，Vue会自动调用 Vue.extend() 函数创建组件，使用方式可简化为：12345678910111213// 在一个步骤中扩展与注册Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;)// 局部注册也可以这么做var Parent = Vue.extend(&#123; components: &#123; &apos;my-component&apos;: &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos; &#125; &#125;&#125;) 使用已注册的组件使用 使用自定义组件（指调用Vue构造函数初始化根实例）之前必须已经创建并且注册组件。123&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; Vue进行模板解析的时候会遵循以下html常见的限制：12345- a 不能包含其它的交互元素（如按钮，链接）- ul 和 ol 只能直接包含 li- select 只能包含 option 和 optgroup- table 只能直接包含 thead, tbody, tfoot, tr, caption, col, colgroup- tr 只能直接包含 th 和 td 对于自定义元素可以使用 is 特性：12345&lt;div id=&quot;example&quot;&gt;&lt;ul&gt; &lt;li is=&quot;my-component&quot;&gt;此处内容不会显示&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt; 组件属性 组件实例的作用域是孤立的，props 用于将数据传给子组件。 props 是选项对象的一个字段，在组件构造时声明，在模板上用属性的方式传入：1234567Vue.component(&apos;child&apos;, &#123; // 声明 props props: [&apos;msg&apos;], // prop 可以用在模板内 // 可以用 `this.msg` 设置 template: &apos;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&apos;&#125;) 1&lt;child msg=&quot;hello!&quot;&gt;&lt;/child&gt; 注意：在 props 中用camelCase声明的字段要转换成kebab-case的方式才会生效。 动态PROPS在子组件中可以使用 v-bind 绑定动态Props到父组件的数据，当父组件的数据变化时，子组件也会跟着改变。1&lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt; PROPS绑定类型prop 默认是单向绑定的，即：父组件的属性变化将传递给子组件，但是子组件的变化不会影响父组件。Vue提供 .sync 和 .once 绑定修饰符用于显示地强制双向或单次绑定：12345678&lt;!-- 默认为单向绑定 --&gt;&lt;child :msg=&quot;parentMsg&quot;&gt;&lt;/child&gt;&lt;!-- 双向绑定 --&gt;&lt;child :msg.sync=&quot;parentMsg&quot;&gt;&lt;/child&gt;&lt;!-- 单次绑定 --&gt;&lt;child :msg.once=&quot;parentMsg&quot;&gt;&lt;/child&gt; 注意：如果prop是一个对象或者数组，Vue是按引用传递数据的，所以无论是否指明双向绑定，实际上都是“双向绑定”的。 PROPS验证指定prop验证的意义在于：约束使用组件的其它人，带验证时 props 字段应该是一个对象：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Vue.component(&apos;example&apos;, &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 (1.0.21+) propM: [String, Number], // 必需且是字符串 propB: &#123; type: String, required: true &#125;, // 数字，有默认值 propC: &#123; type: Number, default: 100 &#125;, // 对象/数组的默认值应当由一个函数返回 propD: &#123; type: Object, default: function () &#123; return &#123; msg: &apos;hello&apos; &#125; &#125; &#125;, // 指定这个 prop 为双向绑定 // 如果绑定类型不对将抛出一条警告 propE: &#123; twoWay: true &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125;, // 转换函数（1.0.12 新增） // 在设置值之前转换值 propG: &#123; coerce: function (val) &#123; return val + &apos;&apos; // 将值转换为字符串 &#125; &#125;, propH: &#123; coerce: function (val) &#123; return JSON.parse(val) // 将 JSON 字符串转换为对象 &#125; &#125; &#125;&#125;); type 可以是下面的原生构造器之一： String Number Boolean Function Obiect Array 也可以是自定义的构造器：使用 instanceof 检测。 组件通信父链父链指的是因组件之间的嵌套关系产生的关系链，Vue定义了三个关于父链的变量： this.$parent:指向父组件的实例； this.$root:指向根对象； this.$children:父组件的一个数组，包含它所有的子元素； 自定义事件Vue的自定义事件接口一共提供四个方法: $on():监听事件； $emit():在组件实例上触发事件； $dispatch():派发事件，沿着父链冒泡； $brjoadcast():广播事件，事件向下传导分为所有后代； 使用方式:1234567891011&lt;!-- 子组件模板 --&gt;&lt;template id=&quot;child-template&quot;&gt; &lt;input v-model=&quot;msg&quot;&gt; &lt;button v-on:click=&quot;notify&quot;&gt;Dispatch Event&lt;/button&gt;&lt;/template&gt;&lt;!-- 父组件模板 --&gt;&lt;div id=&quot;events-example&quot;&gt; &lt;p&gt;Messages: &#123;&#123; messages | json &#125;&#125;&lt;/p&gt; &lt;child v-on:child-msg=&quot;handleIt&quot;&gt;&lt;/child&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132// 注册子组件// 将当前消息派发出去Vue.component(&apos;child&apos;, &#123; template: &apos;#child-template&apos;, data: function () &#123; return &#123; msg: &apos;hello&apos; &#125; &#125;, methods: &#123; notify: function () &#123; if (this.msg.trim()) &#123; this.$emit(&apos;child-msg&apos;, this.msg) this.msg = &apos;&apos; &#125; &#125; &#125;&#125;)// 初始化父组件// 将收到消息时将事件推入一个数组var parent = new Vue(&#123; el: &apos;#events-example&apos;, data: &#123; messages: [] &#125;, // 在创建实例时 `events` 选项简单地调用 `$on` methods: &#123; &apos;handleIt&apos;: function (msg) &#123; // 事件回调内的 `this` 自动绑定到注册它的实例上 this.messages.push(msg) &#125; &#125;&#125;) 注意： 不同于DOM事件，Vue事件在冒泡过程中第一次触发回调之后自动停止冒泡，除非回调明确返回true； Vue的事件时同步机制，执行dispatch后会等待一个返回再接着执行； 子组件索引Vue中可以使用v-ref为子组件指定一个索引ID，用于直接访问子组件。Vue实例的$refs包含父组件中所有制定了v-ref属相的子组件，当执行v-ref和v-for一起使用时$refs是一个数组，否则是一个对象。 组件内容分发Vue使用slot特性进行内容分发 在父组件放入已被slot标记的内容，这些内容的顺序可以随意。之后这些内容被分发到子组件的特殊元素slot中，根据name属性在子组件中重新组合。 需要注意的是，内容应该被放在父组件模板的子组件中：123456789&lt;!--父组件模板--&gt;&lt;div id=&quot;parent-template&quot;&gt; &lt;child&gt; &lt;!--此处是待分发的内容--&gt; &lt;p slot=&quot;one&quot;&gt;one&lt;/p&gt; &lt;p slot=&quot;two&quot;&gt;two&lt;/p&gt; &lt;p&gt;default&lt;/p&gt; &lt;/child&gt;&lt;/div&gt; 父组件模板中的内容被分发到子组件中重新组合，请看子组件的模板：1234567&lt;!--子组件的模板--&gt;&lt;div&gt; &lt;h1&gt;内容被分发且重新组合&lt;/h1&gt; &lt;slot&gt;默认分发处&lt;/slot&gt; &lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;&lt;/div&gt; 初始化父组件实例之前要祖册子组件：1234567891011121314// 注册子组件Vue.component(&quot;child&quot;, &#123; template: &apos;&lt;div&gt;&apos;+ &apos;&lt;h1&gt;内容被分发且重新组合&lt;/h1&gt;&apos;+ &apos;&lt;slot&gt;默认分发处&lt;/slot&gt;&apos;+ &apos;&lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt;&apos;+ &apos;&lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;&apos;+&apos;&lt;/div&gt;&apos;&#125;);// 初始化父组件new Vue(&#123; el: &quot;#parent-template&quot;&#125;); 异步组件Vue允许讲组件定义为一个工厂函数，在组件需要渲染是触发工厂函数动态地解析组件，并且将结果缓存起来：12345678Vue.component(&quot;async-component&quot;, function(resolve, reject)&#123; // async operation setTimeout(function() &#123; resolve(&#123; template: &apos;&lt;div&gt;something async&lt;/div&gt;&apos; &#125;); &#125;,1000);&#125;); 配合WEBPACK实现代码分割webpack可以讲代码分割成块，在需要次块时再使用ajax的方式下载：123456Vue.component(&apos;async-webpack-example&apos;, function(resolve) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 ajax 请求自动下载。 require([&apos;./my-async-component&apos;], resolve)&#125;);]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局笔记]]></title>
    <url>%2F2017%2F11%2F02%2FFlex%E5%B8%83%E5%B1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Flex 布局是什么Flex是Flexible Box的缩写，意思为“弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局。123.box&#123; display : inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀。1234.box&#123; display ：-webkit-flex; /*Safari*/ display : flex;&#125; 注意，设为Flex布局以后，子元素的float、clear、和vertical-align属性将失效。 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上: flex-direction:决定主轴的方向（即项目的排列方向）row(默认值):主轴为水平方向，起点在左端row-reverse:主轴为水平方向，起点在右端column:主轴为垂直方向，起点在上沿column-reverse:主轴为垂直方向，起点在下沿 flex-wrap:定义如果一条轴线排不下，如何换行nowrap(默认值):不换行wrap:换行，第一行在上方wrap-reverse:换行，第一行在下方 flex-flow:flex-direction属性和flex-wrap属性的简写形式&lt;flex-direction&gt; || &lt;flex-wrap&gt; justify-content:定义项目在主轴上的对齐方式flex-start(默认值):左对齐flex-end:右对齐center:居中space-between:两端对齐，项目之间的间隔都相等space-around:每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 align-items:定义练手在交叉轴上如何对齐flex-start:交叉轴的起点对齐flex-end:交叉轴的重点对齐center:交叉轴的中点对齐baseline:项目的第一行文字的基线对齐stretch(默认值):如果项目未设置高度或设为auto，将占满整个容器的高度 align-content:定义了多跟轴线的对齐方式flex-start:与交叉轴的起点对齐flex-end:与交叉轴的终点对齐center:与交叉轴的中点对齐space-between:与交叉轴两端对齐，轴线之间的间隔平均分布space-around:每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍stretch(默认值):轴线占满整个交叉轴 项目的属性以下6个属性设置在项目上: order:定义项目排列顺序&lt;integer&gt;:数值越小，排列越靠前，默认为0。 flex-grow:定义项目的放大比例&lt;number&gt;:默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们等分剩余空间。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 flex-shrink:定义了项目的缩小比例&lt;number&gt;:默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，档空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小 flex-basis:定义了在分配多余空间之前，项目占据的主轴空间(mian size)&lt;length&gt; : | auto:浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值(比如350px)，则项目将占据固定空间 flex:是flex-grow，flex-shrink和flex-basic的简写none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]:默认值为0 1 auto(后两个属性可选)。 align-self:属性允许单个项目有与其他项目不一样的对齐方式auto | flex-start | flex-end | center | baseline | stretch除了auto，其他都与align-items属性完全一致。可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 参考文章：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记(一)]]></title>
    <url>%2F2017%2F10%2F30%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[VueJs： 数据驱动的组件，为现代化的 Web 界面而生 Vue的核心包括两部分： 响应的数据绑定：数据驱动视图，操作数据而非DOM，通过指令实现功能扩展； 组件系统：vue应用可以看成是一棵组件树，vue提供组件间的数据流，自定义事件系统，带特效的组件替换效果等； Vue官网中专门有一篇文章讲Vue和其它框架的对比，个人觉得有点参考价值，从中可以窥见很多Vue重要的特性： 对比 angular Vue专注视图层，更轻，性能占优； Vue只允许父组件单向地传递数据给子组件； Vue不执行脏检查，使用基于依赖追踪的观察系统，且使用异步队列更新； 对比 react Vue建立在真实DOM结构上； 轻量级的 DSL (指令系统)，直观简洁的模板； Vue也有自己的状态管理方案：Vuex； 其它特点 与webpack无缝整合； 支持ES6和CSS预处理器； 另外在组件封装方面，下面一张图就可以很好地展现Vue的特性 demo效果 JS代码在实现这个demo时，Vue的语法显得相当简洁，整个应用的核心逻辑都包裹在一个传输给 Vue 构造函数作为形参的对象中，demo中主要包括：el，data，methods三部分： 1234567891011121314151617181920new Vue(&#123; el: &quot;#app&quot;, // 指定应用的根元素 data: &#123; // 数据 newtodo: &apos;&apos;, todos: [] &#125;, methods: &#123; // 方法 addTodo: function() &#123; if (this.newtodo) &#123; this.todos.push(&#123; text: this.newtodo &#125;); &#125; this.newtodo = &apos;&apos;; &#125;, rmTodo: function(index) &#123; this.todos.splice(index, 1); &#125; &#125;&#125;); HTML结构Vue的 HTML 结构和 angular 有类似的地方：两者都是用 HTML 的方式来扩充 HTML 功能，包括双向数据绑定，循环，事件绑定等 12345678910&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;newtodo&quot;&gt; &lt;button v-on:click=&quot;addTodo&quot;&gt;add&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123;todo.text&#125;&#125; &lt;button v-on:click=&quot;rmTodo($index)&quot;&gt;&amp;Chi;&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 构造函数构件vue应用的第一步是调用Vue构造函数，传入的选项对象包括：数据，模板，挂载元素，方法，生命周期钩子等。 data：每个Vue实例都会代理 data 对象中所有的属性，“代理”属性其实就是建立引用，一方改变，另一方也会变化； 以$开头的属性和方法： 12345678910111213var data = &#123; a: 1 &#125;;var vm = new Vue(&#123; el: &apos;#example&apos;, data: data&#125;);vm.$data === data // -&gt; truevm.$el === document.getElementById(&apos;example&apos;) // -&gt; true// $watch 是一个实例方法vm.$watch(&apos;a&apos;, function (newVal, oldVal) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 生命周期钩子：created，compiled，ready，destroyed等，生命周期的示意图: 数据绑定语法插值 文本Vue的文本插值采用“mustache”双大括号语法，双大括号中的msg表示data中的msg属性字段,like this： 1&lt;span&gt;msg: &#123;&#123;msg&#125;&#125;&lt;/span&gt; HTML要插入原始的HTML需要使用三大括号语法： 1&#123;&#123;&#123; thisis_html &#125;&#125;&#125; 将内容直接以html的方式插入存在风险，建议只对信任的内容做此操作。 HTML特性mustache标签也可用在HTML特性内：1&lt;div class=&quot;item-&#123;&#123;class&#125;&#125;&quot;&gt; 绑定表达式 放在mustache标签内的文本被称为绑定表达式，此表达式内可以由一个简单的JavaScript表达式和可选的过滤器组成。 表达式：单个的表达式内不能有语句和流程控制语句，除此之外支持全功能的JavaScript表达式： 12345&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 过滤器：Vue会以“pipeline”的方式将数据传递给过滤器，语法用 | 表示，同时过滤器也支持传参： 1&#123;&#123; msg | filterA filterA_arg | filterB &#125;&#125; 指令在Vue中，指令以前缀 v- 开头，其职责是：当其表达式的值改变时把某些特殊的行为应用到DOM上。指令的值称为绑定表达式。 指令的参数用冒号 : 隔开，比如 v-bind 指令用于响应的更新html特性，具体的attribute以冒号后参数的形式传递： 1&lt;a v-bind:href = &quot;url&quot;&gt;&lt;/a&gt; 缩写vue提供特定指令的缩写形式： v-bind：缩写形式中可以直接去掉v-bind：1&lt;a :href = &quot;url&quot;&gt;&lt;/a&gt;; v-on：用 @ 表示：1&lt;a @click = &quot;dosomething&quot;&gt;; 计算属性计算属性是一个function，在function中返回一个值，这个值可能会依赖于其它数据，定义在 computed 属性下：123456789101112var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125;, computed: &#123; fullName: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125;&#125;) Class与Style绑定 Vue对Class与Style绑定做了专门优化，支持对象与数组语法。 Class 对象语法 1&lt;div v-bind:class=&quot;&#123;&apos;class-a&apos;: isA, &apos;class-b&apos;: isB&apos;&#125;&quot;&gt;&lt;/div&gt; 数组语法 1&lt;div v-bind:class=&quot;[classA, classB]&quot;&gt; 数组语法与对象语法不同之处在于：对象语法中data里存的是属性值命名的字段，而数组中则直接是数组元素命名的字段。 Stylestyle绑定语法与class类似，不再赘述，如12&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;div v-bind:style=&quot;[styleObjectA, styleObjectB]&quot;&gt; 条件渲染 v-if：根据 v-if 绑定的值来控制是否渲染DOM，其可以配合 &lt;template&gt;&lt;/template&gt; 实现多个元素的渲染控制，此外还可搭配 v-show 语法： 12345&lt;template v-if=&quot;isShow&quot;&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;p&gt;this is content.&lt;/p&gt;&lt;/template&gt;&lt;p v-else&gt;sorry.&lt;/p&gt; v-show：根据绑定值控制DOM元素是否显示。使用方法与 v-if 类似。但不可使用 &lt;template&gt; 和 v-show。 两者的区别在于 v-if 是真实的条件渲染，而 v-show 只是控制 display 属性来展示/隐藏元素，DOM元素始终存在，具体使用哪个应该根据场景切换频率来定。 列表渲染列表渲染使用 v-for ，使用方法如下： 12345&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125;&#125;) 方法与事件处理基本的使用方法：1&lt;button v-on:click=&quot;say(&apos;hello!&apos;, $event)&quot;&gt;Submit&lt;/button&gt; 123456methods: &#123; say: function (msg, event) &#123; // 现在我们可以访问原生事件对象 event.preventDefault() &#125;&#125; ##事件修饰符 Vue为 event.preventDefault() 和 event.stopPropagation() 提供了两个修饰符：.prevent 和 .stop：1234567891011&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt; 1.0.16 添加了两个额外的修饰符：12345&lt;!-- 添加事件侦听器时使用 capture 模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 表单控件绑定 使用 v-model 指令在表单元素上创建双向数据绑定。 常见表单元素的绑定方式如下：1234567891011121314151617181920212223242526272829303132333435363738&lt;!--text--&gt;&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;!--textarea--&gt;&lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;&lt;!--checkbox--&gt;&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;!--radio：不需要通过name来绑定一组radio--&gt;&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;&lt;br&gt;&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;&lt;!--select：option有value选项时取value值，否则去innerText值--&gt;&lt;select v-model=&quot;selected&quot;&gt; &lt;option selected&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;!--v-model配合v-bind使用以绑定value到动态属性上--&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;pick&quot; v-bind:true-value=&quot;a&quot; v-bind:false-value=&quot;b&quot;&gt;&lt;span&gt;Selected: &#123;&#123; pick &#125;&#125;&lt;/span&gt;&lt;!--使用lazy参数将事件从input变为change--&gt;&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model=&quot;msg&quot; lazy&gt;&lt;!--将用户的输入转为 Number 类型（如果原值的转换结果为 NaN 则返回原值） --&gt;&lt;input v-model=&quot;age&quot; number&gt;&lt;!--debounce 设置一个最小的延时，在每次敲击之后延时同步输入框的值与数据。--&gt;&lt;!--注意 debounce 参数不会延迟 input 事件：它延迟“写入”底层数据。--&gt;&lt;input v-model=&quot;msg&quot; debounce=&quot;500&quot;&gt;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式大全]]></title>
    <url>%2F2017%2F10%2F30%2FCSS%E6%A0%B7%E5%BC%8F%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[本文可以作为一个平时使用的css参考手册，文章来源于网上，具体见文章末尾。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284字体属性：(font)大小 &#123;font-size: x-large;&#125;(特大) xx-small;(极小) 一般中文用不到，只要用数值就可以，单位：PX、PD样式 &#123;font-style: oblique;&#125;(偏斜体) italic;(斜体) normal;(正常)行高 &#123;line-height: normal;&#125;(正常) 单位：PX、PD、EM粗细 &#123;font-weight: bold;&#125;(粗体) lighter;(细体) normal;(正常)变体 &#123;font-variant: small-caps;&#125;(小型大写字母) normal;(正常)大小写 &#123;text-transform: capitalize;&#125;(首字母大写) uppercase;(大写) lowercase;(小写) none;(无)修饰 &#123;text-decoration: underline;&#125;(下划线) overline;(上划线) line-through;(删除线) blink;(闪烁)常用字体： (font-family)&quot;Courier New&quot;, Courier, monospace, &quot;Times New Roman&quot;,Times, serif, Arial, Helvetica, sans-serif, Verdana背景属性： (background)色彩 &#123;background-color: #FFFFFF;&#125;图片 &#123;background-image: url();&#125;重复 &#123;background-repeat: no-repeat;&#125;滚动 &#123;background-attachment: fixed;&#125;(固定) scroll;(滚动)位置 &#123;background-position: left;&#125;(水平) top(垂直);简写方法 &#123;background:#000 url(..) repeat fixed left top;&#125;/*简写·这个在阅读代码中经常出现，要认真的研究*/区块属性： (Block) /*这个属性第一次认识，要多多研究*/字间距 &#123;letter-spacing: normal;&#125; 数值 /*这个属性似乎有用，多实践下*/对齐 &#123;text-align: justify;&#125;(两端对齐) left;(左对齐) rightright;(右对齐) center;(居中)缩进 &#123;text-indent: 数值px;&#125;垂直对齐 &#123;vertical-align: baselinebaseline;&#125;(基线) sub;(下标) super;(下标) top; text-top; middle; bottombottom; text-bottom;词间距word-spacing: normal; 数值空格whitewhite-space: pre;(保留) nowrap;(不换行)显示 &#123;display:block;&#125;(块) inline;(内嵌) list-item;(列表项) run-in;(追加部分) compact;(紧凑)marker;(标记)table; inline-table; table-raw-group; table-header-group;table-footer-group;table-raw; table-column-group; table-column;table-cell; table-caption;(表格标题) /*display 属性的了解很模糊*/方框属性： (Box)width:; height:; float:; clear:both; margin:; padding:; 顺序：上右下左边框属性： (Border)border-style: dotted;(点线) dashed;(虚线) solid; double;(双线)groove;(槽线) ridge;(脊状) inset;(凹陷) outset;border-width:; 边框宽度border-color:#;简写方法border：width style color; /*简写*/列表属性： (List-style)类型list-style-type: disc;(圆点) circle;(圆圈) square;(方块) decimal;(数字)lower-roman;(小罗码数字) upper-roman; lower-alpha; upper-alpha;位置list-style-position: outside;(外) inside;图像list-style-image: url(..);定位属性： (Position)Position: absolute; relative; static;visibility: inherit; visible; hidden;overflow: visible; hidden; scroll; auto;clip: rect(12px,auto,12px,auto) (裁切)css属性代码大全一 CSS文字属性：color : #999999; /*文字颜色*/font-family : 宋体,sans-serif; /*文字字体*/font-size : 9pt; /*文字大小*/font-style:itelic; /*文字斜体*/font-variant:small-caps; /*小字体*/letter-spacing : 1pt; /*字间距离*/line-height : 200%; /*设置行高*/font-weight:bold; /*文字粗体*/vertical-align:sub; /*下标字*/vertical-align:super; /*上标字*/text-decoration:line-through; /*加删除线*/text-decoration: overline; /*加顶线*/text-decoration:underline; /*加下划线*/text-decoration:none; /*删除链接下划线*/text-transform : capitalize; /*首字大写*/text-transform : uppercase; /*英文大写*/text-transform : lowercase; /*英文小写*/text-align:rightright; /*文字右对齐*/text-align:left; /*文字左对齐*/text-align:center; /*文字居中对齐*/text-align:justify; /*文字分散对齐*/vertical-align属性vertical-align:top; /*垂直向上对齐*/vertical-align:bottombottom; /*垂直向下对齐*/vertical-align:middle; /*垂直居中对齐*/vertical-align:text-top; /*文字垂直向上对齐*/vertical-align:text-bottom; /*文字垂直向下对齐*/二、CSS边框空白padding-top:10px; /*上边框留空白*/padding-right:10px; /*右边框留空白*/padding-bottom:10px; /*下边框留空白*/padding-left:10px; /*左边框留空白三、CSS符号属性：list-style-type:none; /*不编号*/list-style-type:decimal; /*阿拉伯数字*/list-style-type:lower-roman; /*小写罗马数字*/list-style-type:upper-roman; /*大写罗马数字*/list-style-type:lower-alpha; /*小写英文字母*/list-style-type:upper-alpha; /*大写英文字母*/list-style-type:disc; /*实心圆形符号*/list-style-type:circle; /*空心圆形符号*/list-style-type:square; /*实心方形符号*/list-style-image:url(/dot.gif); /*图片式符号*/list-style-position: outside; /*凸排*/list-style-position:inside; /*缩进*/四、CSS背景样式：background-color:#F5E2EC; /*背景颜色*/background:transparent; /*透视背景*/background-image : url(/image/bg.gif); /*背景图片*/background-attachment : fixed; /*浮水印固定背景*/background-repeat : repeat; /*重复排列-网页默认*/background-repeat : no-repeat; /*不重复排列*/background-repeat : repeat-x; /*在x轴重复排列*/background-repeat : repeat-y; /*在y轴重复排列*/指定背景位置background-position : 90% 90%; /*背景图片x与y轴的位置*/background-position : top; /*向上对齐*/background-position : buttom; /*向下对齐*/background-position : left; /*向左对齐*/background-position : rightright; /*向右对齐*/background-position : center; /*居中对齐*/五、CSS连接属性：a /*所有超链接*/a:link /*超链接文字格式*/a:visited /*浏览过的链接文字格式*/a:active /*按下链接的格式*/a:hover /*鼠标转到链接*/鼠标光标样式：链接手指 CURSOR: hand十字体 cursor:crosshair箭头朝下 cursor:s-resize十字箭头 cursor:move箭头朝右 cursor:move加一问号 cursor:help箭头朝左 cursor:w-resize箭头朝上 cursor:n-resize箭头朝右上 cursor:ne-resize箭头朝左上 cursor:nw-resize文字I型 cursor:text箭头斜右下 cursor:se-resize箭头斜左下 cursor:sw-resize漏斗 cursor:wait光标图案(IE6) p &#123;cursor:url(&quot;光标文件名.cur&quot;),text;&#125;六、CSS框线一览表：border-top : 1px solid #6699cc; /*上框线*/border-bottom : 1px solid #6699cc; /*下框线*/border-left : 1px solid #6699cc; /*左框线*/border-right : 1px solid #6699cc; /*右框线*/以上是建议书写方式,但也可以使用常规的方式 如下:border-top-color : #369 /*设置上框线top颜色*/border-top-width :1px /*设置上框线top宽度*/border-top-style : solid/*设置上框线top样式*/其他框线样式solid /*实线框*/dotted /*虚线框*/double /*双线框*/groove /*立体内凸框*/ridge /*立体浮雕框*/inset /*凹框*/outset /*凸框*/七、CSS表单运用：文字方块按钮复选框选择钮多行文字方块下拉式菜单 选项1选项2八、CSS边界样式：margin-top:10px; /*上边界*/margin-right:10px; /*右边界值*/margin-bottom:10px; /*下边界值*/margin-left:10px; /*左边界值*/CSS 属性： 字体样式(Font Style)序号 中文说明 标记语法1 字体样式 &#123;font:font-style font-variant font-weight font-size font-family&#125;2 字体类型 &#123;font-family:&quot;字体1&quot;,&quot;字体2&quot;,&quot;字体3&quot;,...&#125;3 字体大小 &#123;font-size:数值|inherit| medium| large| larger| x-large| xx-large| small| smaller| x-small| xx-small&#125;4 字体风格 &#123;font-style:inherit|italic|normal|oblique&#125;5 字体粗细 &#123;font-weight:100-900|bold|bolder|lighter|normal;&#125;6 字体颜色 &#123;color:数值;&#125;7 阴影颜色 &#123;text-shadow:16位色值&#125;8 字体行高 &#123;line-height:数值|inherit|normal;&#125;9 字 间 距 &#123;letter-spacing:数值|inherit|normal&#125;10 单词间距 &#123;word-spacing:数值|inherit|normal&#125;11 字体变形 &#123;font-variant:inherit|normal|small-cps &#125;12 英文转换 &#123;text-transform:inherit|none|capitalize|uppercase|lowercase&#125;13 字体变形 &#123;font-size-adjust:inherit|none&#125;14 字体 &#123;font-stretch:condensed|expanded|extra-condensed|extra-expanded|inherit|narrower|normal| semi-condensed|semi-expanded|ultra-condensed|ultra-expanded|wider&#125;文本样式(Text Style)序号 中文说明 标记语法1 行 间 距 &#123;line-height:数值|inherit|normal;&#125;2 文本修饰 &#123;text-decoration:inherit|none|underline|overline|line-through|blink&#125;3 段首空格 &#123;text-indent:数值|inherit&#125;4 水平对齐 &#123;text-align:left|rightright|center|justify&#125;5 垂直对齐 &#123;vertical-align:inherit|top|bottombottom|text-top|text-bottom|baselinebaseline|middle|sub|super&#125;6 书写方式 &#123;writing-mode:lr-tb|tb-rl&#125;背景样式序号 中文说明 标记语法1 背景颜色 &#123;background-color:数值&#125;2 背景图片 &#123;background-image: url(URL)|none&#125;3 背景重复 &#123;background-repeat:inherit|no-repeat|repeat|repeat-x|repeat-y&#125;4 背景固定 &#123;background-attachment:fixed|scroll&#125;5 背景定位 &#123;background-position:数值|top|bottombottom|left|rightright|center&#125;6 背影样式 &#123;background:背景颜色|背景图象|背景重复|背景附件|背景位置&#125;框架样式(Box Style)序号 中文说明 标记语法1 边界留白 &#123;margin:margin-top margin-right margin-bottom margin-left&#125;2 补 白 &#123;padding:padding-top padding-right padding-bottom padding-left&#125;3 边框宽度 &#123;border-width:border-top-width border-right-width border-bottom-width border-left-width&#125;宽度值： thin|medium|thick|数值4 边框颜色 &#123;border-color:数值 数值 数值 数值&#125; 数值：分别代表top、rightright、bottombottom、left颜色值5 边框风格 &#123;border-style:none|hidden|inherit|dashed|solid|double|inset|outset|ridge|groove&#125;6 边 框 &#123;border:border-width border-style color&#125;上 边 框 &#123;border-top:border-top-width border-style color&#125;右 边 框 &#123;border-right:border-right-width border-style color&#125;下 边 框 &#123;border-bottom:border-bottom-width border-style color&#125;左 边 框 &#123;border-left:border-left-width border-style color&#125;7 宽 度 &#123;width:长度|百分比| auto&#125;8 高 度 &#123;height:数值|auto&#125;9 漂 浮 &#123;float:left|rightright|none&#125;10 清 除 &#123;clear:none|left|rightright|both&#125;分类列表序号 中文说明 标记语法1 控制显示 &#123;display:none|block|inline|list-item&#125;2 控制空白 &#123;whitewhite-space:normal|pre|nowarp&#125;3 符号列表 &#123;list-style-type:disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none&#125;4 图形列表 &#123;list-style-image:URL&#125;5 位置列表 &#123;list-style-position:inside|outside&#125;6 目录列表 &#123;list-style:目录样式类型|目录样式位置|url&#125;7 鼠标形状 &#123;cursor:hand|crosshair|text|wait|move|help|e-resize|nw-resize|w-resize|s-resize|se-resize|sw-resize&#125; 文章来源：https://150643.com/442.html]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JSON]]></title>
    <url>%2F2017%2F10%2F13%2F%E5%85%B3%E4%BA%8EJSON%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前一直误以为JavaScript中的对象字面量（Object Literals）就是JSON对象，因为它的语法和JSON规范里描述的一样,但是该规范也明确地说了JSON只是一个数据交换语言，只有我们将其用在string上下文的时候它才叫JSON。 序列化与反序列化&emsp;&emsp;两个程序（或服务器、语言等）需要交互通信的时候，他们倾向于使用string字符串因为string在很多语言里解析的方式都差不多。复杂的数据结构经常需要用到，并且通过各种各样的中括号{}，小括号()，方括号[]和空格来组成，这个字符串仅仅是按照要求规范好的字符。 &emsp;&emsp;为此，我们为了描述这些复杂的数据结构作为一个string字符串，制定了标准的规则和语法。JSON只是其中一种语法，它可以在string上下文里描述对象，数组，字符串，数字，布尔型和null，然后通过程序间传输，并且反序列化成所需要的格式。YAML和XML也是流行的数据交换格式，但是作为前端开发人员都喜欢JSON。 字面量 它们是固定的值，不是变量，让你从”字面上”了解脚本。 字符串字面量是有双引号（”）或单引号（’）包围起来的零个或多个字符组成的。 对象字面量是由大括号（{}）括起来的零个或多个对象的属性名-值对。 何时是JSON，何时不是JSON？&emsp;&emsp;JSON是设计成描述数据焦金环格式的，它也有自己的语法这个语法是JavaScript的一个子集。{ “prop”: “val” } 这样的声明有可能是JavaScript对象字面量也有可能是JSON字符串，取决于什么上下文使用它，如果是用在string上下文（用单引号或双引号引住，或者从text文件读取）的话，那它就是JSON字符串，如果是用在对象字面量上下文中，那它就是对象字面量。 12345//这是JSON字符串var foo = &apos;&#123;&quot;prop&quot; : &quot;val&quot;&#125;&apos;;//这是对象字面量var bar = &#123;&quot;prop&quot; : &quot;val&quot;&#125;; &emsp;&emsp;而且要注意，JSON有非常严格的语法，在string上下文里{“prop” : “val”}是个合法的JSON，但是{prop : “val”}确实不合法。所有属性名称和它的值都必须用双引号引住，不能使用单引号。另外，即便你使用了了转义以后的单引号也是不合法的，详细的一发规则可以这里查看。 真正的JSON对象&emsp;&emsp;开头已经提到，对象字面量不是JSON对象，但是有真正的JSON对象。但是两者完全不一样概念，在新版的浏览器里JSON对象已经被原生的内置对象了，目前有2个静态方法：JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。老版本的浏览器不支持这个对象，但可以通过json2.js来实现同样的功能。 可以参考下边的例子： 12345678910// 这是JSON字符串，比如从AJAX获取字符串信息var my_json_string = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;; // 将字符串反序列化成对象var my_obj = JSON.parse( my_json_string ); alert( my_obj.prop == &apos;val&apos; ); // 提示 true, 和想象的一样! // 将对象序列化成JSON字符串var my_other_json_string = JSON.stringify( my_obj ); 参考文章：http://www.cnblogs.com/zichi/p/4360219.html]]></content>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在博客中插入jsfiddle代码]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5jsfiddle%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前看到有些博文里可以把HTML、CSS、JavaScript代码和运行结果直接显示在一个iframe中，就觉得这个方式挺有用的。首先是不占据多少文章地方，主要是比较清晰，代码和结果一目了然。今天特地去找了一下是利用什么来实现的。网上搜了一会，大概明白了如何实现，下面是预览效果(请耐心等待一下，可能加载有点慢)： &emsp;&emsp;下面来说说实现的步骤： 进入jsfiddle官网注册jsfiddle账号&emsp;&emsp;然后可以看到如下页面： 将html、css、js分别写在指定的位置当中，最后一个框result是显示效果的；依次点击Run、Save，然后在embed中可以得到EMBED CODE,这里点击右边的Perfer iframe？，复制代码到你的markdown中。在Embed的TABS中可以勾选你想要显示的内容。然后在你复制的代码中也可以进行编辑：1&lt;iframe width=&quot;100%&quot; height=&quot;400&quot; src=&quot;//jsfiddle.net/akaziki/9msfwc6w/embedded/html,css,result/&quot; allowfullscreen=&quot;allowfullscreen&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &emsp;&emsp;jsfiddle.net/akaziki/9msfwc6w是你的代码链接，html,css,result是要显示的内容和顺序。 可参考网站：http://doc.jsfiddle.net/]]></content>
      <tags>
        <tag>博客</tag>
        <tag>Jsfiddle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器的权重问题]]></title>
    <url>%2F2017%2F10%2F11%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E6%9D%83%E9%87%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[正文：&emsp;&emsp;css选择器的权重问题一直以来都是困扰我的一件事情。为了解决选择器能如期地修改样式，我总是在想要用的选择器前边加上多个选择器以提高优先级。可是这样做有个缺点，就是下次你要重新再修改样式时需要添加更高优先级的选择器。另一方面就是代码冗余的问题，盲目地添加选择器只会提高代码的混乱度。为此我重新系统地学习了一下关于各个选择器的权值。下面是各个选择器的权重： 通配选择符的权值 0,0,0,0标签的权值为 0,0,0,1类的权值为 0,0,1,0属性选择的权值为 0,0,1,1 0,0,1,0伪类选择的权值为 0,0,1,0伪对象选择的权值为 0,0,0,1ID的权值为 0,1,0,0!important的权值为最高 1,0,0,0 &emsp;&emsp;了解了各个选择器的权值后，就可以更加清晰地知道自己该用哪些选择器了。这里说一下选择器的使用规则，就是选择器的权值加到一起，权值大的优先。如果权值相同，后定义的优先。所以在使用选择器的时候，应进行适当的计算，避免css的重复定义以造成代码的冗余,还有就是不要一味地添加选择器的数量来来提高优先级。 其他福利：&emsp;&emsp;很多人本来就对选择器之前的权重关系拎不清，当下，各种CSS3伪类纷至沓来，更迷糊了。 &emsp;&emsp;为了拯救我们这些劳苦命的的页面仔们，国外有人制作了一个很通俗易懂的，大鱼吃小鱼，小鱼吃小虾，小虾吃泥巴的CSS选择器类型与权重关系图： 参考文章：http://www.zhangxinxu.com/wordpress/2012/08/256-class-selector-beat-id-selector/]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈EJS]]></title>
    <url>%2F2017%2F10%2F09%2F%E6%B5%85%E8%B0%88EJS%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在知乎看了许多“关于nodejs的模板引擎，如何选择EJS和Jade？”这个问题的回答，对EJS和Jade有了大概的的初步印象，也基本了解到了swig这个模板。EJS的结构更像HTML，但是Jade更加简洁，swig的特性还是不大了解。鉴于自己处于入门级，然后选择EJS的人也比较多，所以就找了EJS的一些资料进行学习。下面是一些个人的理解和一些供自己以后参考的笔记。 什么是EJS&emsp;&emsp;简单来说EJS就是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。 为什么要使用EJS&emsp;&emsp;与最初的JavaScript相比较，一些不太了解你的代码的人可以更容易地通过EJS模板代码看得懂你的代码。 &emsp;&emsp;这里我找了一个比较浅显易懂的例子： &emsp;&emsp;这是用javascript实现的代码 12345678910var html = &quot;&lt;h1&gt;&quot;+data.title+&quot;&lt;/h1&gt;&quot;html += &quot;&lt;ul&gt;&quot;for(var i=0; i&lt;data.supplies.length; i++) &#123; html += &quot;&lt;li&gt;&lt;a href=&apos;supplies/&quot;+data.supplies[i]+&quot;&apos;&gt;&quot; html += data.supplies[i]+&quot;&lt;/a&gt;&lt;/li&gt;&quot;&#125;html += &quot;&lt;/ul&gt;&quot; &emsp;&emsp;最终要实现的效果如下 &emsp;&emsp;但是上面的代码看起来很乱，虽然实现了功能，但是不容易让人弄懂，而且HTML结构完全在JavaScript代码中丢失。 &emsp;&emsp;下面学习EJS同样实现上面的功效，它的工作原理如下： &emsp;&emsp;使用EJS来找回你的明确、维护性良好的HTML代码结构。注:data是json对象，不能使json字符串。 &emsp;&emsp;在HTML中引入EJS,以使javascript能够使用它，引入EJS的语句如下： &lt;script type=&quot;text/javascript&quot; src=&quot;/js/ejs.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;创建一个EJS模板,命名为cleaning.ejs文件，内容如下 12345678&lt;h1&gt;&lt;%=title %&gt;&lt;/h1&gt;&lt;ul&gt;&lt;% for ( var i=0; i&lt;supplies.length; i++) &#123; %&gt; &lt;li&gt; &lt;a href= &apos;supplies/&lt;%=supplies[i] %&gt;&apos; &gt;&lt;%= supplies[i] %&gt;&lt;/a&gt; &lt;/li&gt;&lt;% &#125; %&gt;&lt;/ul&gt; &emsp;&emsp;HTML文档如下，引入EJS,并创建EJS对象，然后调用EJS对象成员函数解析JSON对象到模板中。 123456789101112131415161718&lt; html &gt;&lt; head &gt;&lt; script type = &quot;text/javascript&quot; src = &quot;/js/ejs.js&quot; &gt;&lt;/ script &gt;&lt; script type = &quot;text/javascript&quot; &gt; function myfunction()&#123; var data=&apos;&#123;&quot;title&quot;:&quot;cleaning&quot;,&quot;supplies&quot;:[&quot;mop&quot;,&quot;broom&quot;,&quot;duster&quot;]&#125;&apos; var html = new EJS(&#123;url: &apos;cleaning.ejs&apos;&#125;).render(JSON.parse(data)) //JSON.parse(data) 把JSON字符串解析为原生的javascript值 alert(html); document.getElementById(&quot;div1&quot;).innerHTML=html; &#125;&lt;/ script &gt;&lt;/ head &gt;&lt; body &gt; &lt;button onclick = &quot;myfunction()&quot; &gt;点击&lt;/button&gt; &lt; div id = &quot;div1&quot; &gt;&lt;/ div &gt;&lt;/ body&gt;&lt; html &gt; &emsp;&emsp;从上面这个例子我们可以看到EJS模板的基本用法 EJS的语法和功能：1、缓存功能，能够缓存已经解析好的html模版； 2、&lt;% code %&gt;用于执行其中javascript代码，如： &lt;% alert(&apos;hello world&apos;) %&gt; 3、&lt;%= code %&gt;会对code进行html转义； &emsp;&emsp;下面是一些语法例子： 12345678&lt;!-- 把title里面存的值给显示出来在h1中。 --&gt;&lt;h1&gt;&lt;% =title %&gt;&lt;/h1&gt;&lt;!-- 把hello world显示在h1中。 --&gt;&lt;p&gt;&lt;% =&apos;hello world&apos; %&gt;&lt;/p&gt;&lt;!-- 把hello world变粗，然后显示在h1中。 --&gt;&lt;h1&gt;&lt;% =&apos;&lt;b&gt;hello world&lt;/b&gt;&apos; %&gt;&lt;/h1&gt; 4、&lt;%- code %&gt;将不会进行转义；这一行代码不会执行，像是被注释了一样，然后显示原来的html。也不会影响整个页面的执行。 &lt;h1&gt;&lt;%-title %&gt;asd&lt;/h1&gt; 最后显示asd，及显示原网页 &lt;p&gt;&lt;% #&apos;hello world&apos; %&gt;asd&lt;/p&gt; 最后显示asd，及显示原网页 5、EJS里，默认的闭合标记是 &lt;% .. %&gt;，我们也可以通过app.set()定义自己的标签。例如： 123456app.set(&quot;view options&quot;,&#123; &quot;open&quot;:&quot;&#123;&#123;&quot;, &quot;close&quot;:&quot;&#125;&#125;&quot;&#125;); 6、一些辅助函数，用于模版中使用(留着用来供查阅使用) 1)、first，返回数组的第一个元素；2)、last，返回数组的最后一个元素；3)、capitalize，返回首字母大写的字符串；4)、downcase，返回字符串的小写；5)、upcase，返回字符串的大写；6)、sort，排序（Object.create(obj).sort()？）；7)、sort_by:’prop’，按照指定的prop属性进行升序排序；8)、size，返回长度，即length属性，不一定非是数组才行；9)、plus:n，加上n，将转化为Number进行运算；10)、minus:n，减去n，将转化为Number进行运算；11)、times:n，乘以n，将转化为Number进行运算；12)、divided_by:n，除以n，将转化为Number进行运算；13)、join:’val’，将数组用’val’最为分隔符，进行合并成一个字符串；14)、truncate:n，截取前n个字符，超过长度时，将返回一个副本15)、truncate_words:n，取得字符串中的前n个word，word以空格进行分割；16)、replace:pattern,substitution，字符串替换，substitution不提供将删除匹配的子串；17)、prepend:val，如果操作数为数组，则进行合并；为字符串则添加val在前面；18)、append:val，如果操作数为数组，则进行合并；为字符串则添加val在后面；19)、map:’prop’，返回对象数组中属性为prop的值组成的数组；20)、reverse，翻转数组或字符串；21)、get:’prop’，取得属性为’prop’的值；22)、json，转化为json格式字符串 7、利用&lt;%- include filename %&gt;加载其他页面模版； 使用创建好的EJS模板&emsp;&emsp;基于我们之前写的模拟生成一个EJS对象 new EJS({url: &apos;cleaning.ejs&apos;}) &emsp;&emsp;对象有下面两个成员函数 ejs.compile(str, options); //将返回内部解析好的Function函数 ejs.render(str, options); //返回经过解析的字符串 &emsp;&emsp;ejs的render函数有两个参数 第一个是字符串，第二个是可选的对象，和其他javascript模版一样需要渲染的数据也是包含在option对象中的。 ejs.render(str,option); // 渲染字符串 str 一般是通过nodejs文件系统的readfile方法读取 ejs.render(str,{data : user_data // 需要渲染的数据}); 其中options的一些参数为: 1、cache：是否缓存解析后的模版，需要filename作为key；2、filename：模版文件名；3、scope：complile后的Function执行所在的上下文环境；4、debug：标识是否是debeg状态，debug为true则会输出生成的Function内容；5、compileDebug：标识是否是编译debug，为true则会生成解析过程中的跟踪信息，用于调试；6、client，标识是否用于浏览器客户端运行，为true则返回解析后的可以单独运行的Function函数；7、open，代码开头标记，默认为’&lt;%’；8、close，代码结束标记，默认为’%&gt;’；9、其他的一些用于解析模版时提供的变量。 EJS的应用场所1、用JavaScript创建HTML字符串 正如我们在新手教程中所讨论的，在JavaScript中拼字符串的缺点是可维护性不好。当你在JavaScript中将这些字符串拼到一起时，很难看出你正在写的HTML是什么---你页面展现的结构过于混乱。而使用EJS模板可以让你通过代码的空行和缩进来清楚地展现出你的HTML。 2、基于WebService的AJAX网站开发 EJS可以接收WebService异步传送过来的JSON格式的数据，将这种数据直接传入你的模板里，然后将结果插入到你的页面中。你所需要做的只是通过以下代码 new EJS({url: &apos;comments.ejs&apos;}).update(&apos;element_id&apos;, &apos;/comments.json&apos;)]]></content>
      <tags>
        <tag>Ejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO添加评论系统]]></title>
    <url>%2F2017%2F10%2F08%2Fhexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[(10月9号更新…)emmmmm…特意过来更新一下。因为一直都是在墙外，所以测试的时候没有考虑到Disqus国内能不能用的问题。昨天朋友说看不到我的评论系统才醒悟过来。所以现在国内基本没有可以直接用的评论系统了，然后朋友就自己搭建了一个(膜拜大佬)，还写了篇博文来说明具体步骤。奈何我是github page，不能直接使用他的评论系统。有兴趣的话可以到我朋友博客看看。 &emsp;&emsp;文章主要描述了hexo静态博客框架通过Disqus来添加评论功能的详细步骤。之所以选择disqus的原因是多说、网易云跟帖已经停止运营了，然后畅言需要进行ICP备案(我有句mmp…)。剩下的选择只有disqus了，而且disqus不需要主题支持，hexo的_config.yml本身就可以进行配置。 &emsp;&emsp;以我自己博客所选主题yilia为例，在 themes/yilia/路径下的_config.yml文件中，disqus设置为真disqus: true，并添加disqus相关项 disqus_shortname: akaziki(你自己的disqus的website name)，akaziki为你在Disqus上配置的site的shorname（接下来会配置shortname），Disqus的配置步骤如下: &emsp;&emsp;Disqus网址，注册完账号登录后点击左上角Home跳转到主页，然后点GET STARTED，再次跳转后选择I want to install Disqus on my site，然后在新页面中填写你的website name、type和language，如下图： &emsp;&emsp;创建成功后，在新页面点击Install Disqus，Platform选择为Universal Code，拉到页面最下面点击按钮即可。 &emsp;&emsp;然后点击Configure Disqus，将Website Name改为你想要的名称，我的为akaziki，URL设置为你的Github page地址，然后完成。 &emsp;&emsp;基本上所有步骤都进行完了，你可以依次执行clean，generate和deploy来部署。]]></content>
      <tags>
        <tag>HEXO</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown使用小技巧]]></title>
    <url>%2F2017%2F10%2F02%2FMarkDown%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[写作目的在看了一些MarkDown的入门语法之后，发现许多的文档对一些比较细微的问题缺乏解释。所以打算再进行补充一下。 目标读者使用MarkDown仅仅为了排版出更好看的文章，而不关注技术细节，不懂HTML的用户。 1、首行缩进写文章时，我们常常希望能够首行缩进，这时可以在段首加入&ensp;来输入一个空格.加入&emsp;来输入两个空格。 示例文本1&amp;emsp;&amp;emsp;一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！&quot; 效果 &emsp;&emsp;一语未了，只听后院中有人笑声，说：“我来迟了，不曾迎接远客！ 2、插入代码插入代码的方式有两种 在每行代码前加入4个空格或者添加一个制表符（TAB键） 在代码两侧添加三个反引号‘```’。 两种方法都有需要注意的地方，很多入门文档未能提及。 2.1 方式1其缩进是相对于当前格式状态下的。 示例文本 列表项 列表项[TAB][TAB]printf(“hello world!”); 效果 列表项 列表项printf(&quot;hello world!&quot;); 在列表项状态下，需要输入两次TAB键(制表符)才能以代码格式插入(本主题下的代码颜色显示有点怪异)。 2.2 方式2反引号最好在代码的前后行添加，而不是直接加在代码两边。 示例文本 ```var sta = “swift你好，我叫akaziki”println(sta)``` 效果12var sta = &quot;swift你好，我叫akaziki&quot;println(sta) 3、添加空行添加空行可以结束先前的格式状态。个人建议在改变格式时，均添加一个空行。 示例文本 >引用状态[空行]###标题状态[空行]------[空行]- 列表状态- 列表状态 效果 引用状态 标题状态 列表状态 列表状态 4、其他 普通段落尽量不用空格或制表符来缩进，即使使用它们后得到的效果看似是对的。 [数字] + ‘.’ + [空格] 的形式会呼出有序的项目列表。因此如果你在正文中恰好出现这种形式，那么可以在‘.’的前面加上‘\’来避免出现有序列表。 2017-10-02]]></content>
      <tags>
        <tag>博客</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
